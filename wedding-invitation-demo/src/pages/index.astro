---
import '../styles/global.css';
---

<html lang="ko">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>김철수 ♥ 이영희 결혼식</title>
		<meta name="description" content="김철수와 이영희의 결혼식에 초대합니다" />
	</head>
	<body class="text-gray-800 font-sans bg-rose-50">
		<!-- 커튼 효과 요소들 -->
		<div id="curtain-overlay" class="fixed inset-0 z-50 pointer-events-none" data-curtain="true" style="display: block;">
			<!-- 초기 전체 화면 덮개 -->
			<div id="initial-overlay" class="absolute bg-white" style="z-index: 50; display: block; position: absolute; inset: 0; background-color: white; opacity: 0;" data-curtain="initial-overlay"><!-- 초기 화면 덮개 --></div>
			
			<!-- 4개의 하얀 사각형 -->
			<div id="curtain-top-left" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel"><!-- 커튼 패널 --></div>
			<div id="curtain-top-right" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel"><!-- 커튼 패널 --></div>
			<div id="curtain-bottom-left" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel"><!-- 커튼 패널 --></div>
			<div id="curtain-bottom-right" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel"><!-- 커튼 패널 --></div>
			
			<!-- 초기 회색 가로줄 -->
			<div id="initial-gray-line-left" class="absolute bg-gray-400" style="z-index: 53; display: block; height: 2px; opacity: 0;" data-curtain="initial-line"><!-- 초기 가로줄 왼쪽 --></div>
			<div id="initial-gray-line-right" class="absolute bg-gray-400" style="z-index: 53; display: block; height: 2px; opacity: 0;" data-curtain="initial-line"><!-- 초기 가로줄 오른쪽 --></div>
			
			<!-- 20개의 주름 세로선 -->
			<svg id="wrinkles-container" style="z-index: 52; display: block; position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none;" data-curtain="wrinkles">
				<!-- 주름 선들이 여기에 동적으로 추가됩니다 -->
			</svg>
		</div>

		<main class="max-w-md mx-auto bg-white min-h-screen">
			
			<!-- Phase 1: 필수 요소 -->
			
			<!-- 1. 신랑신부 정보 + 2. 결혼식 정보 -->
			<section class="text-center py-12 px-6 bg-gradient-to-b from-rose-100 to-white">
				<div class="mb-8">
					<h1 class="text-3xl font-bold text-rose-800 mb-2">
						김철수 ♥ 이영희
					</h1>
					<p class="text-sm text-gray-600 mb-4">
						김○○ · 박○○ 의 장남 철수<br>
						이○○ · 최○○ 의 장녀 영희
					</p>
				</div>
				
				<div class="bg-white rounded-lg p-6 shadow-lg mb-6">
					<div class="text-lg font-semibold text-gray-800 mb-3">결혼식</div>
					<div class="text-gray-600 space-y-1">
						<div>2024년 12월 25일 (수)</div>
						<div>오후 2시</div>
						<div>서울 중구 웨딩홀</div>
						<div class="text-sm text-gray-500">3층 로즈홀</div>
					</div>
				</div>
			</section>
			
			<!-- 3. 인사말 -->
			<section class="px-6 py-8 bg-white">
				<div class="text-center mb-6">
					<h2 class="text-xl font-semibold text-gray-800 mb-4">인사말</h2>
				</div>
				<div class="text-gray-700 leading-relaxed text-center space-y-3">
					<p>
						저희 두 사람이 사랑으로 하나가 되어<br>
						새로운 인생의 출발을 하려고 합니다.
					</p>
					<p>
						부족한 저희를 아껴주시고 사랑해 주신<br>
						모든 분들께 감사드리며,
					</p>
					<p>
						앞으로도 변함없이 따뜻한 관심과<br>
						격려 부탁드립니다.
					</p>
					<div class="pt-4">
						<div class="font-semibold">김철수 · 이영희</div>
					</div>
				</div>
			</section>
			
			<!-- 4. 연락처 -->
			<section class="px-6 py-8 bg-gray-50">
				<h2 class="text-xl font-semibold text-gray-800 mb-6 text-center">연락처</h2>
				<div class="space-y-6">
					<div class="text-center">
						<div class="font-semibold text-gray-800 mb-2">신랑</div>
						<div class="text-gray-600">김철수</div>
						<a href="tel:010-1234-5678" class="text-rose-600 hover:text-rose-700">010-1234-5678</a>
					</div>
					<div class="text-center">
						<div class="font-semibold text-gray-800 mb-2">신부</div>
						<div class="text-gray-600">이영희</div>
						<a href="tel:010-9876-5432" class="text-rose-600 hover:text-rose-700">010-9876-5432</a>
					</div>
				</div>
			</section>
			
			<!-- 5. 오시는 길 -->
			<section class="px-6 py-8 bg-white">
				<h2 class="text-xl font-semibold text-gray-800 mb-6 text-center">오시는 길</h2>
				<div class="bg-gray-100 rounded-lg p-4 mb-4">
					<div class="font-semibold mb-2">서울 중구 웨딩홀</div>
					<div class="text-gray-600 text-sm space-y-1">
						<div>서울특별시 중구 세종대로 123</div>
						<div>지하철 1호선 종각역 3번 출구</div>
						<div>도보 5분</div>
					</div>
				</div>
				<div class="text-center">
					<button class="bg-rose-600 text-white px-6 py-3 rounded-lg hover:bg-rose-700 transition-colors">
						지도보기
					</button>
				</div>
			</section>
			
			<!-- 6. 갤러리 -->
			<section class="px-6 py-8 bg-gray-50">
				<h2 class="text-xl font-semibold text-gray-800 mb-6 text-center">갤러리</h2>
				<div class="grid grid-cols-2 gap-4">
					<div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center">
						<span class="text-gray-500">사진 1</span>
					</div>
					<div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center">
						<span class="text-gray-500">사진 2</span>
					</div>
					<div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center">
						<span class="text-gray-500">사진 3</span>
					</div>
					<div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center">
						<span class="text-gray-500">사진 4</span>
					</div>
				</div>
			</section>
			
			<!-- 7. 마음 전하실 곳 -->
			<section class="px-6 py-8 bg-white">
				<h2 class="text-xl font-semibold text-gray-800 mb-6 text-center">마음 전하실 곳</h2>
				<div class="space-y-4">
					<div class="bg-gray-50 rounded-lg p-4">
						<div class="font-semibold text-gray-800 mb-2">신랑측</div>
						<div class="text-sm text-gray-600 space-y-1">
							<div>국민은행 123-456-789012</div>
							<div>김철수</div>
						</div>
					</div>
					<div class="bg-gray-50 rounded-lg p-4">
						<div class="font-semibold text-gray-800 mb-2">신부측</div>
						<div class="text-sm text-gray-600 space-y-1">
							<div>우리은행 987-654-321098</div>
							<div>이영희</div>
						</div>
					</div>
				</div>
			</section>
			
			<!-- 8. 감사 인사 -->
			<section class="px-6 py-12 bg-rose-100 text-center">
				<div class="text-gray-700 space-y-3">
					<p class="text-lg font-medium">소중한 분들과 함께</p>
					<p>더욱 행복한 저희가 되겠습니다</p>
					<div class="pt-4">
						<div class="text-rose-800 font-semibold text-xl">감사합니다 ♥</div>
					</div>
				</div>
			</section>
			
		</main>

		<script>
			class CurtainEffect {
				constructor() {
					// 뷰포트 크기
					this.viewportWidth = window.innerWidth;
					this.viewportHeight = window.innerHeight;
					this.centerX = this.viewportWidth / 2;
					this.centerY = this.viewportHeight / 2;
					
					// 요소들
					this.overlay = document.getElementById('curtain-overlay');
					this.initialOverlay = document.getElementById('initial-overlay');
					this.topLeft = document.getElementById('curtain-top-left');
					this.topRight = document.getElementById('curtain-top-right');
					this.bottomLeft = document.getElementById('curtain-bottom-left');
					this.bottomRight = document.getElementById('curtain-bottom-right');
					this.leftLine = document.getElementById('initial-gray-line-left');
					this.rightLine = document.getElementById('initial-gray-line-right');
					this.wrinklesContainer = document.getElementById('wrinkles-container');
					
					// 애니메이션 관련
					this.isAnimating = false;
					this.phase = 0;
					
					// 페이즈별 지속시간
					this.initialWaitDuration = 1000; // 페이지 로드 후 대기 (1초)
					this.phase0Duration = 500; // 초기 회색 가로줄 생성 (500ms)
					this.phase0WaitDuration = 1000; // 휴면 시간 (1000ms)
					this.phase1Duration = 400; // 꼭지점 이동 (400ms)
					this.phase2Duration = 300; // 대기 시간 (300ms)
					this.phase3Duration = 2000; // 커튼 이동 + 주름 (2초)
					this.totalDuration = this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration + this.phase1Duration + this.phase2Duration + this.phase3Duration;
					
					this.startTime = null;
					this.wrinkleLines = [];
					
					// 주름 관리
					this.wrinkles = [];
					
					// 초기 설정
					this.init();
				}
				
				init() {
					// 초기 상태 설정
					this.setupInitialState();
					
					// 주름 생성
					this.createWrinkles();
					
					// 애니메이션 시작
					this.startAnimation();
				}
				
				setupInitialState() {
					// 초기 전체 화면 덮개
					this.initialOverlay.style.opacity = '1';
					
					// 4개 사각형 초기 위치
					this.topLeft.style.cssText = `
						z-index: 51;
						display: block;
						position: absolute;
						background-color: white;
						left: 0px;
						top: 0px;
						width: ${this.centerX}px;
						height: ${this.centerY}px;
						clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
					`;
					
					this.topRight.style.cssText = `
						z-index: 51;
						display: block;
						position: absolute;
						background-color: white;
						left: ${this.centerX}px;
						top: 0px;
						width: ${this.centerX}px;
						height: ${this.centerY}px;
						clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
					`;
					
					this.bottomLeft.style.cssText = `
						z-index: 51;
						display: block;
						position: absolute;
						background-color: white;
						left: 0px;
						top: ${this.centerY}px;
						width: ${this.centerX}px;
						height: ${this.centerY}px;
						clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
					`;
					
					this.bottomRight.style.cssText = `
						z-index: 51;
						display: block;
						position: absolute;
						background-color: white;
						left: ${this.centerX}px;
						top: ${this.centerY}px;
						width: ${this.centerX}px;
						height: ${this.centerY}px;
						clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
					`;
					
					// 회색 가로줄 초기 설정
					this.leftLine.style.cssText = `
						z-index: 53;
						display: block;
						height: 2px;
						opacity: 0;
						position: absolute;
						top: ${this.centerY - 1}px;
						left: 0px;
						width: ${this.centerX}px;
						background-color: rgb(156, 163, 175);
					`;
					
					this.rightLine.style.cssText = `
						z-index: 53;
						display: block;
						height: 2px;
						opacity: 0;
						position: absolute;
						top: ${this.centerY - 1}px;
						left: ${this.centerX}px;
						width: ${this.centerX}px;
						background-color: rgb(156, 163, 175);
					`;
				}
				
				createWrinkles() {
					// 각 섹션별로 5개씩, 총 20개 주름 생성
					const sections = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
					
					sections.forEach(section => {
						for (let i = 1; i <= 5; i++) {
							const wrinkle = this.createWrinkle(section, i);
							this.wrinkles.push(wrinkle);
						}
					});
				}
				
				createWrinkle(section, index) {
					const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
					
					// 섹션별 기본 위치 계산
					const isLeft = section.includes('left');
					const isTop = section.includes('top');
					
					// 섹션 크기
					const sectionWidth = isLeft ? this.centerX : (this.viewportWidth - this.centerX);
					const sectionHeight = isTop ? this.centerY : (this.viewportHeight - this.centerY);
					
					// x 좌표: 각 섹션을 6등분하여 1~5번째에 배치
					const spacing = sectionWidth / 6;
					const relativeX = spacing * index;
					const absoluteX = isLeft ? relativeX : (this.centerX + relativeX);
					
					// y 좌표: 섹션 전체 높이
					const startY = isTop ? 0 : this.centerY;
					const endY = isTop ? this.centerY : this.viewportHeight;
					
					// 초기에는 세로선
					line.setAttribute('x1', absoluteX);
					line.setAttribute('y1', startY);
					line.setAttribute('x2', absoluteX);
					line.setAttribute('y2', endY);
					line.setAttribute('stroke', '#9CA3AF');
					line.setAttribute('stroke-width', '1');
					line.setAttribute('opacity', '0');
					line.style.transition = 'opacity 0.1s ease-out';
					
					// SVG에 추가
					this.wrinklesContainer.appendChild(line);
					
					return {
						element: line,
						section: section,
						index: index,
						originalX: absoluteX,
						originalY: startY,
						originalHeight: sectionHeight,
						isActive: false,
						activationCurtainMove: null, // 주름이 활성화될 때의 커튼 이동량
						screenPointMoving: false, // 화면 맞닿는 점이 이동하기 시작했는지
						rotationEndCoords: null, // 회전 종료 시점의 좌표
						linearStartCurtainX: null // 선형 이동 시작 시점의 커튼 X 좌표
					};
				}
				
				startAnimation() {
					this.isAnimating = true;
					this.startTime = Date.now();
					this.animate();
				}
				
				animate() {
					if (!this.isAnimating) return;
					
					const now = Date.now();
					const elapsed = now - this.startTime;
					
					// 현재 페이즈와 진행률 계산
					let currentPhase = 0;
					let phaseProgress = 0;
					
					if (elapsed < this.initialWaitDuration) {
						// 초기 대기 시간
						currentPhase = -1;
						phaseProgress = elapsed / this.initialWaitDuration;
					} else if (elapsed < this.initialWaitDuration + this.phase0Duration) {
						// 페이즈 0: 회색 가로줄 페이드인
						currentPhase = 0;
						phaseProgress = (elapsed - this.initialWaitDuration) / this.phase0Duration;
					} else if (elapsed < this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration) {
						// 페이즈 0.5: 대기
						currentPhase = 0.5;
						phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration) / this.phase0WaitDuration;
					} else if (elapsed < this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration + this.phase1Duration) {
						// 페이즈 1: 꼭지점 이동
						currentPhase = 1;
						phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration - this.phase0WaitDuration) / this.phase1Duration;
					} else if (elapsed < this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration + this.phase1Duration + this.phase2Duration) {
						// 페이즈 2: 대기
						currentPhase = 2;
						phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration - this.phase0WaitDuration - this.phase1Duration) / this.phase2Duration;
					} else if (elapsed < this.totalDuration) {
						// 페이즈 3: 커튼 이동
						currentPhase = 3;
						phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration - this.phase0WaitDuration - this.phase1Duration - this.phase2Duration) / this.phase3Duration;
					} else {
						// 애니메이션 종료
						this.cleanup();
						return;
					}
					
					this.updateAnimation(currentPhase, phaseProgress);
					
					// 다음 프레임 요청
					requestAnimationFrame(() => this.animate());
				}
				
				updateAnimation(currentPhase, phaseProgress) {
					const leftLine = this.leftLine;
					const rightLine = this.rightLine;
					
					if (currentPhase === -1) {
						// 초기 대기 시간: 전체 화면 덮개 서서히 사라짐
						const fadeOut = 1 - this.easeOutCubic(phaseProgress);
						this.initialOverlay.style.opacity = fadeOut;
						
					} else if (currentPhase === 0) {
						// 페이즈 0: 회색 가로줄 페이드인 (200ms)
						const opacity = this.easeOutCubic(phaseProgress);
						leftLine.style.opacity = opacity;
						rightLine.style.opacity = opacity;
						
					} else if (currentPhase === 0.5) {
						// 페이즈 0.5: 휴면 상태 (300ms) - 완전 보임
						leftLine.style.opacity = '1';
						rightLine.style.opacity = '1';
						
					} else if (currentPhase === 1) {
						// 페이즈 1: 꼭지점 이동과 함께 띠가 중앙에서 벌어짐 (찢어지는 효과)
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const cornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
						
						// 왼쪽 띠: 중심에서 왼쪽으로 벌어짐
						leftLine.style.left = '0px';
						leftLine.style.width = (this.centerX - cornerMove) + 'px';
						
						// 오른쪽 띠: 중심에서 오른쪽으로 벌어짐
						rightLine.style.left = (this.centerX + cornerMove) + 'px';
						rightLine.style.width = (this.viewportWidth - this.centerX - cornerMove) + 'px';
						
					} else if (currentPhase === 2) {
						// 페이즈 2: 대기 - 찢어진 상태 유지
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						
						leftLine.style.left = '0px';
						leftLine.style.width = (this.centerX - maxCornerMove) + 'px';
						leftLine.style.opacity = '1';
						
						rightLine.style.left = (this.centerX + maxCornerMove) + 'px';
						rightLine.style.width = (this.viewportWidth - this.centerX - maxCornerMove) + 'px';
						rightLine.style.opacity = '1';
						
					} else if (currentPhase === 3) {
						// 페이즈 3: 4개 사각형이 모서리쪽으로 이동
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const finalCornerMove = maxCornerMove;
						
						// 띠도 함께 이동
						leftLine.style.left = '0px';
						leftLine.style.width = (this.centerX - finalCornerMove) + 'px';
						
						rightLine.style.left = (this.centerX + finalCornerMove) + 'px';
						rightLine.style.width = (this.viewportWidth - this.centerX - finalCornerMove) + 'px';
						
						// 커튼 사각형 이동
						const maxMove = this.viewportWidth * 1.5;
						const currentMove = maxMove * this.easeInCubic(phaseProgress);
						
						// 왼쪽 상단 - 왼쪽 위로 이동
						const leftCornerX = (this.centerX - finalCornerMove) - currentMove;
						const leftCornerY = this.centerY;
						
						this.topLeft.style.cssText = `
							z-index: 51;
							display: block;
							position: absolute;
							background-color: white;
							left: 0px;
							top: 0px;
							width: ${this.centerX}px;
							height: ${this.centerY}px;
							clip-path: polygon(0% 0%, 100% 0%, ${((leftCornerX / this.centerX) * 100)}% 100%, 0% 100%);
							transform: translateX(${leftCornerX - this.centerX + finalCornerMove}px);
						`;
						
						// 오른쪽 상단 - 오른쪽 위로 이동  
						const rightCornerX = (this.centerX + finalCornerMove) + currentMove;
						const rightCornerY = this.centerY;
						
						this.topRight.style.cssText = `
							z-index: 51;
							display: block;
							position: absolute;
							background-color: white;
							left: ${this.centerX}px;
							top: 0px;
							width: ${this.centerX}px;
							height: ${this.centerY}px;
							clip-path: polygon(0% 0%, 100% 0%, 100% 100%, ${(((rightCornerX - this.centerX) / this.centerX) * 100)}% 100%);
							transform: translateX(${rightCornerX - this.centerX - finalCornerMove}px);
						`;
						
						// 왼쪽 하단 - 왼쪽 아래로 이동
						this.bottomLeft.style.cssText = `
							z-index: 51;
							display: block;
							position: absolute;
							background-color: white;
							left: 0px;
							top: ${this.centerY}px;
							width: ${this.centerX}px;
							height: ${this.centerY}px;
							clip-path: polygon(0% 0%, ${((leftCornerX / this.centerX) * 100)}% 0%, 100% 100%, 0% 100%);
							transform: translateX(${leftCornerX - this.centerX + finalCornerMove}px);
						`;
						
						// 오른쪽 하단 - 오른쪽 아래로 이동
						this.bottomRight.style.cssText = `
							z-index: 51;
							display: block;
							position: absolute;
							background-color: white;
							left: ${this.centerX}px;
							top: ${this.centerY}px;
							width: ${this.centerX}px;
							height: ${this.centerY}px;
							clip-path: polygon(${(((rightCornerX - this.centerX) / this.centerX) * 100)}% 0%, 100% 0%, 100% 100%, 0% 100%);
							transform: translateX(${rightCornerX - this.centerX - finalCornerMove}px);
						`;
						
						// 주름 업데이트
						this.updateWrinkles(currentPhase, phaseProgress, leftCornerX, rightCornerX);
					}
				}
				
				updateWrinkles(currentPhase, phaseProgress, leftCornerX, rightCornerX) {
					if (currentPhase === 3) {
						this.wrinkles.forEach(wrinkle => {
							if (!wrinkle.isActive) {
								// 주름 활성화 조건 확인
								const isLeftSection = wrinkle.section.includes('left');
								
								// 섹션별 기준점
								const sectionWidth = isLeftSection ? this.centerX : (this.viewportWidth - this.centerX);
								const spacing = sectionWidth / 6; // x = 주름 간격
								const wrinkleX = wrinkle.originalX; // 주름의 x 좌표
								
								// 조기 활성화: x/5만큼 일찍 시작
								const earlyOffset = spacing / 5; // x/5
								
								// 활성화 조건: 커튼 꼭지점이 주름 위치에 x/5만큼 일찍 도달
								const shouldActivate = isLeftSection ? 
									(leftCornerX <= (wrinkleX - earlyOffset)) :   
									(rightCornerX >= (wrinkleX + earlyOffset));
								
								if (shouldActivate) {
									wrinkle.isActive = true;
									wrinkle.element.style.opacity = '1';
								}
							}
							
							// 활성화된 주름만 처리
							if (wrinkle.isActive) {
								// 회전 정지 조건 확인 (화면 점 이동 시작)
								if (!wrinkle.screenPointMoving) {
									const isLeftSection = wrinkle.section.includes('left');
									
									// 섹션별 기준점
									const sectionWidth = isLeftSection ? this.centerX : (this.viewportWidth - this.centerX);
									const spacing = sectionWidth / 6; // x = 주름 간격
									
									// 중심에 가까운 순서대로 n 계산 (0부터 시작)
									const n = isLeftSection ? 
										(5 - wrinkle.index) :  // 왼쪽: left-5가 n=0, left-1이 n=4
										(wrinkle.index - 1);   // 오른쪽: right-1이 n=0, right-5가 n=4
									
									// 커튼 이동점 (leftCornerX 또는 rightCornerX)
									const curtainMovingX = isLeftSection ? leftCornerX : rightCornerX;
									const curtainTotalMove = Math.abs(curtainMovingX - this.centerX);
									
									// 주름이 활성화될 때의 커튼 이동량 저장
									if (wrinkle.activationCurtainMove === null) {
										wrinkle.activationCurtainMove = curtainTotalMove;
									}
									
									// 회전 정지 조건: 활성화 후 x*(6-n)/6만큼 추가 이동
									const additionalMoveNeeded = spacing * (6 - n) / 6; // x*(6-n)/6
									const rotationStopMove = wrinkle.activationCurtainMove + additionalMoveNeeded;
									
									// 조건 달성 시 화면 점 이동 시작
									if (curtainTotalMove >= rotationStopMove) {
										
										// 회전이 끝나는 시점의 좌표를 화면점/커튼점으로 명확히 구분해서 저장
										const isTopSection = wrinkle.section.includes('top');
										wrinkle.rotationEndCoords = {
											screenX: isTopSection ? parseFloat(wrinkle.element.getAttribute('x1')) : parseFloat(wrinkle.element.getAttribute('x2')),
											screenY: isTopSection ? parseFloat(wrinkle.element.getAttribute('y1')) : parseFloat(wrinkle.element.getAttribute('y2')),
											curtainX: isTopSection ? parseFloat(wrinkle.element.getAttribute('x2')) : parseFloat(wrinkle.element.getAttribute('x1')),
											curtainY: isTopSection ? parseFloat(wrinkle.element.getAttribute('y2')) : parseFloat(wrinkle.element.getAttribute('y1'))
										};
										
										// 이동 시작 시점의 커튼 위치 저장
										const isLeftSection = wrinkle.section.includes('left');
										wrinkle.linearStartCurtainX = isLeftSection ? leftCornerX : rightCornerX;
										wrinkle.screenPointMoving = true;
									}
								}
								
								// 주름 업데이트 (회전 또는 이동)
								if (wrinkle.screenPointMoving) {
									// 선형 이동 모드
									this.updateWrinkleLinearMovement(wrinkle, currentPhase, phaseProgress);
								} else {
									// 회전 모드
									this.updateWrinkleTilt(wrinkle, currentPhase, phaseProgress);
								}
							}
						});
					}
				}
				
				updateWrinkleTilt(wrinkle, currentPhase, phaseProgress) {
					const isLeftSection = wrinkle.section.includes('left');
					const isTopSection = wrinkle.section.includes('top');
					
					// 회전 모드: 화면 맞닿는 점 고정
					const fixedX = wrinkle.originalX;
					const fixedY = isTopSection ? wrinkle.originalY : (wrinkle.originalY + wrinkle.originalHeight); // top이면 위점 고정, bottom이면 아래점 고정
					
					// 꼭지점 위치 계산
					let cornerX, cornerY;
					
					if (currentPhase === 1) {
						// 페이즈 1: clipPath 기반 꼭지점 이동
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const currentCornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
						
						cornerX = isLeftSection ? (this.centerX - currentCornerMove) : (this.centerX + currentCornerMove);
						cornerY = this.centerY;
						
					} else if (currentPhase >= 3) {
						// 페이즈 3: transform 기반 전체 이동
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const finalCornerMove = maxCornerMove;
						
						const maxMove = this.viewportWidth * 1.5;
						const currentMove = maxMove * this.easeInCubic(phaseProgress);
						
						cornerX = isLeftSection ? 
							((this.centerX - finalCornerMove) - currentMove) : 
							((this.centerX + finalCornerMove) + currentMove);
						cornerY = this.centerY;
					}
					
					if (cornerX !== undefined && cornerY !== undefined) {
						// 이동점은 반드시 꼭지점 이동경로(y = this.centerY)에 맞닿아야 함
						const movingX = cornerX;
						const movingY = this.centerY; // 꼭지점 이동경로인 중앙 가로선에 고정
						
						// 고정점에서 이동점까지의 실제 거리 계산 (길이가 늘어남)
						const dx = movingX - fixedX;
						const dy = movingY - fixedY;
						const currentLength = Math.sqrt(dx * dx + dy * dy);
						
						// 원래 섹션 높이 (회전하지 않을 때)
						const originalSectionHeight = isTopSection ? this.centerY : (this.viewportHeight - this.centerY);
						
						// 기본 회전각 c 계산 (1페이즈 완료 시 커튼 기울기)
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const basicAngle = Math.atan(maxCornerMove / originalSectionHeight);
						
						// 현재 회전각 계산 (꼭지점 이동에 비례)
						const currentCornerMove = Math.abs(cornerX - this.centerX);
						const currentAngle = Math.atan(currentCornerMove / originalSectionHeight);
						
						// 최대 회전각 y는 기본각의 3배로 설정
						const maxAngle = basicAngle * 3;
						const rotationAngle = Math.min(currentAngle, maxAngle);
						
						// 실제 좌표는 이미 계산됨 (이동점이 꼭지점 경로에 맞닿음)
						const newMovingX = movingX;
						const newMovingY = movingY;
						
						// SVG 라인 업데이트
						if (isTopSection) {
							// top 섹션: 위점 고정, 아래점 이동
							wrinkle.element.setAttribute('x1', fixedX);
							wrinkle.element.setAttribute('y1', fixedY);
							wrinkle.element.setAttribute('x2', newMovingX);
							wrinkle.element.setAttribute('y2', newMovingY);
						} else {
							// bottom 섹션: 아래점 고정, 위점 이동
							wrinkle.element.setAttribute('x1', newMovingX);
							wrinkle.element.setAttribute('y1', newMovingY);
							wrinkle.element.setAttribute('x2', fixedX);
							wrinkle.element.setAttribute('y2', fixedY);
						}
					}
				}
				
				updateWrinkleLinearMovement(wrinkle, currentPhase, phaseProgress) {
					const isLeftSection = wrinkle.section.includes('left');
					const isTopSection = wrinkle.section.includes('top');
					
					// 저장된 좌표가 없으면 현재 좌표를 화면점/커튼점으로 구분해서 저장
					if (!wrinkle.rotationEndCoords) {
						// 저장된 좌표가 없으면 현재 좌표를 화면점/커튼점으로 구분해서 저장
						wrinkle.rotationEndCoords = {
							screenX: isTopSection ? parseFloat(wrinkle.element.getAttribute('x1')) : parseFloat(wrinkle.element.getAttribute('x2')),
							screenY: isTopSection ? parseFloat(wrinkle.element.getAttribute('y1')) : parseFloat(wrinkle.element.getAttribute('y2')),
							curtainX: isTopSection ? parseFloat(wrinkle.element.getAttribute('x2')) : parseFloat(wrinkle.element.getAttribute('x1')),
							curtainY: isTopSection ? parseFloat(wrinkle.element.getAttribute('y2')) : parseFloat(wrinkle.element.getAttribute('y1'))
						};
					}
					
					// 꼭지점 위치 계산 (커튼 이동점)
					let cornerX, cornerY;
					
					if (currentPhase === 1) {
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const currentCornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
						cornerX = isLeftSection ? (this.centerX - currentCornerMove) : (this.centerX + currentCornerMove);
						cornerY = this.centerY;
					} else if (currentPhase >= 3) {
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const finalCornerMove = maxCornerMove;
						const maxMove = this.viewportWidth * 1.5;
						const currentMove = maxMove * this.easeInCubic(phaseProgress);
						cornerX = isLeftSection ? 
							((this.centerX - finalCornerMove) - currentMove) : 
							((this.centerX + finalCornerMove) + currentMove);
						cornerY = this.centerY;
					}
					
					if (cornerX !== undefined && cornerY !== undefined) {
						// 화면 맞닿는 점: 회전 종료 시점 위치에서 커튼과 같은 속도로 이동
						const direction = isLeftSection ? -1 : 1;
						const maxMove = this.viewportWidth * 1.5;
						// 커튼의 실제 이동량 계산
						const currentCurtainX = isLeftSection ? 
							(cornerX || (this.centerX - Math.min(this.centerX, this.centerY) * 0.2)) : 
							(cornerX || (this.centerX + Math.min(this.centerX, this.centerY) * 0.2));
						const currentMove = Math.abs(currentCurtainX - wrinkle.linearStartCurtainX);
						
						// 회전 종료 시점의 화면 맞닿는 점에서 추가 이동
						const screenMovingX = wrinkle.rotationEndCoords.screenX + (direction * currentMove);
						const screenMovingY = wrinkle.rotationEndCoords.screenY;
						
						
						// SVG 라인 업데이트: 회전된 상태를 유지하면서 이동
						if (isTopSection) {
							// top 섹션: x1=화면점, x2=커튼점
							wrinkle.element.setAttribute('x1', screenMovingX);
							wrinkle.element.setAttribute('y1', screenMovingY);
							wrinkle.element.setAttribute('x2', cornerX);
							wrinkle.element.setAttribute('y2', cornerY);
						} else {
							// bottom 섹션: x1=커튼점, x2=화면점
							wrinkle.element.setAttribute('x1', cornerX);
							wrinkle.element.setAttribute('y1', cornerY);
							wrinkle.element.setAttribute('x2', screenMovingX);
							wrinkle.element.setAttribute('y2', screenMovingY);
						}
						
					}
				}
				
				cleanup() {
					// 애니메이션 완료 후 모든 커튼 요소 제거
					const overlay = document.getElementById('curtain-overlay');
					overlay.style.opacity = '0';
					setTimeout(() => {
						overlay.remove();
					}, 300);
				}
				
				// Easing 함수들
				easeOutCubic(t) {
					return 1 - Math.pow(1 - t, 3);
				}
				
				easeInCubic(t) {
					return t * t * t;
				}
			}
			
			// DOM이 로드되면 커튼 효과 시작
			document.addEventListener('DOMContentLoaded', () => {
				new CurtainEffect();
			});
		</script>
	</body>
</html>
