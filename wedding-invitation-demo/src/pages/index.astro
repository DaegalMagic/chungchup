---
import '../styles/global.css';
---

<html lang="ko">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>김철수 ♥ 이영희 결혼식</title>
		<meta name="description" content="김철수와 이영희의 결혼식에 초대합니다" />
	</head>
	<body class="text-gray-800 font-sans bg-rose-50">
		<!-- 커튼 효과 요소들 -->
		<div id="curtain-overlay" class="fixed inset-0 z-50 pointer-events-none" data-curtain="true" style="display: block;">
			<!-- 초기 전체 화면 덮개 -->
			<div id="initial-overlay" class="absolute bg-white" style="z-index: 50; display: block; position: absolute; inset: 0; background-color: white; opacity: 0;" data-curtain="initial-overlay"><!-- 초기 화면 덮개 --></div>
			
			<!-- 4개의 하얀 사각형 -->
			<div id="curtain-top-left" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel"><!-- 커튼 패널 --></div>
			<div id="curtain-top-right" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel"><!-- 커튼 패널 --></div>
			<div id="curtain-bottom-left" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel"><!-- 커튼 패널 --></div>
			<div id="curtain-bottom-right" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel"><!-- 커튼 패널 --></div>
			
			<!-- 초기 회색 가로줄 -->
			<div id="initial-gray-line-left" class="absolute bg-gray-400" style="z-index: 53; display: block; height: 2px; opacity: 0;" data-curtain="initial-line"><!-- 초기 가로줄 왼쪽 --></div>
			<div id="initial-gray-line-right" class="absolute bg-gray-400" style="z-index: 53; display: block; height: 2px; opacity: 0;" data-curtain="initial-line"><!-- 초기 가로줄 오른쪽 --></div>
			
			<!-- 20개의 주름 세로선 -->
			<svg id="wrinkles-container" style="z-index: 52; display: block; position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none;" data-curtain="wrinkles">
				<!-- 주름 선들이 여기에 동적으로 추가됩니다 -->
			</svg>
		</div>

		<main class="max-w-md mx-auto bg-white min-h-screen">
			
			<!-- Phase 1: 필수 요소 -->
			
			<!-- 1. 신랑신부 정보 + 2. 결혼식 정보 -->
			<section class="text-center py-12 px-6 bg-gradient-to-b from-rose-100 to-white">
				<div class="mb-8">
					<h1 class="text-3xl font-bold text-rose-800 mb-2">
						김철수 ♥ 이영희
					</h1>
					<p class="text-sm text-gray-600 mb-4">
						김○○ · 박○○ 의 장남 철수<br>
						이○○ · 최○○ 의 장녀 영희
					</p>
				</div>
				
				<div class="text-center">
					<h2 class="text-xl font-semibold text-gray-700 mb-2">
						2024년 10월 25일 토요일
					</h2>
					<p class="text-lg text-rose-700">
						오후 2시
					</p>
				</div>
			</section>

			<!-- 6. 메인 사진 -->
			<section class="px-6 py-8">
				<div class="w-full h-80 bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300">
					<span class="text-gray-500 text-lg font-medium">[메인 웨딩사진]</span>
				</div>
			</section>

			<!-- 5. 기본 인사말 -->
			<section class="px-6 py-8 text-center">
				<div class="bg-rose-50 rounded-lg p-6">
					<h3 class="text-lg font-semibold mb-4 text-rose-800">소중한 분들께</h3>
					<p class="text-gray-700 leading-relaxed">
						[기본 인사말]<br>
						저희 두 사람이 사랑의 결실을 맺게 되었습니다.<br>
						소중한 분들과 함께 새로운 시작을 하고자 합니다.<br>
						바쁘신 중에도 참석하시어 축복해 주시면<br>
						더없는 기쁨이겠습니다.
					</p>
				</div>
			</section>

			<!-- 3. 장소 정보 -->
			<section class="px-6 py-8">
				<h3 class="text-xl font-semibold text-center mb-6 text-rose-800">오시는 길</h3>
				
				<!-- 지도 영역 -->
				<div class="w-full h-48 bg-gray-200 rounded-lg mb-4 flex items-center justify-center border-2 border-dashed border-gray-300">
					<span class="text-gray-500 text-lg font-medium">[카카오맵]</span>
				</div>
				
				<div class="text-center">
					<h4 class="text-lg font-semibold mb-2">서울웨딩홀</h4>
					<p class="text-gray-600 mb-2">3층 그레이스홀</p>
					<p class="text-sm text-gray-500">서울시 강남구 테헤란로 123</p>
				</div>
			</section>

			<!-- 4. 연락처 -->
			<section class="px-6 py-8">
				<h3 class="text-xl font-semibold text-center mb-6 text-rose-800">연락처</h3>
				
				<div class="grid grid-cols-2 gap-4">
					<!-- 신랑측 -->
					<div class="text-center bg-blue-50 rounded-lg p-4">
						<h4 class="font-semibold mb-3 text-blue-800">신랑측</h4>
						<div class="space-y-2 text-sm">
							<div>
								<p class="font-medium">김철수</p>
								<button class="text-blue-600 underline">010-1234-5678</button>
							</div>
							<div>
								<p class="font-medium">아버지 김○○</p>
								<button class="text-blue-600 underline">010-1111-2222</button>
							</div>
							<div>
								<p class="font-medium">어머니 박○○</p>
								<button class="text-blue-600 underline">010-3333-4444</button>
							</div>
						</div>
					</div>
					
					<!-- 신부측 -->
					<div class="text-center bg-pink-50 rounded-lg p-4">
						<h4 class="font-semibold mb-3 text-pink-800">신부측</h4>
						<div class="space-y-2 text-sm">
							<div>
								<p class="font-medium">이영희</p>
								<button class="text-pink-600 underline">010-5678-9012</button>
							</div>
							<div>
								<p class="font-medium">아버지 이○○</p>
								<button class="text-pink-600 underline">010-5555-6666</button>
							</div>
							<div>
								<p class="font-medium">어머니 최○○</p>
								<button class="text-pink-600 underline">010-7777-8888</button>
							</div>
						</div>
					</div>
				</div>
			</section>

			<!-- Phase 2: 거의 필수 요소 -->

			<!-- 7. 사진 갤러리 -->
			<section class="px-6 py-8">
				<h3 class="text-xl font-semibold text-center mb-6 text-rose-800">갤러리</h3>
				
				<div class="grid grid-cols-2 gap-3">
					<div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300">
						<span class="text-gray-500 text-sm">[사진1]</span>
					</div>
					<div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300">
						<span class="text-gray-500 text-sm">[사진2]</span>
					</div>
					<div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300">
						<span class="text-gray-500 text-sm">[사진3]</span>
					</div>
					<div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300">
						<span class="text-gray-500 text-sm">[사진4]</span>
					</div>
				</div>
				
				<div class="text-center mt-4">
					<button class="text-rose-600 underline text-sm">더 많은 사진 보기</button>
				</div>
			</section>

			<!-- 8. 계좌 정보 -->
			<section class="px-6 py-8">
				<h3 class="text-xl font-semibold text-center mb-6 text-rose-800">마음 전하실 곳</h3>
				
				<div class="space-y-4">
					<!-- 신랑측 계좌 -->
					<div class="bg-blue-50 rounded-lg p-4">
						<h4 class="font-semibold mb-3 text-blue-800 text-center">신랑측</h4>
						<div class="space-y-2">
							<div class="flex justify-between items-center bg-white rounded p-3">
								<div>
									<p class="font-medium">국민은행</p>
									<p class="text-sm text-gray-600">123-456-789012</p>
									<p class="text-sm">예금주: 김철수</p>
								</div>
								<button class="text-blue-600 text-sm underline">복사</button>
							</div>
						</div>
					</div>
					
					<!-- 신부측 계좌 -->
					<div class="bg-pink-50 rounded-lg p-4">
						<h4 class="font-semibold mb-3 text-pink-800 text-center">신부측</h4>
						<div class="space-y-2">
							<div class="flex justify-between items-center bg-white rounded p-3">
								<div>
									<p class="font-medium">신한은행</p>
									<p class="text-sm text-gray-600">987-654-321098</p>
									<p class="text-sm">예금주: 이영희</p>
								</div>
								<button class="text-pink-600 text-sm underline">복사</button>
							</div>
						</div>
					</div>
				</div>
			</section>

			<!-- 9. 상세 인사말 -->
			<section class="px-6 py-8">
				<h3 class="text-xl font-semibold text-center mb-6 text-rose-800">진심을 담아</h3>
				
				<div class="bg-gradient-to-b from-rose-50 to-white rounded-lg p-6">
					<p class="text-gray-700 leading-relaxed text-center">
						[상세 인사말]<br><br>
						
						안녕하세요, 저희는 3년 전 대학교 동아리에서 만나<br>
						서로의 소중함을 알게 되었습니다.<br><br>
						
						이제 평생을 함께하겠다는 약속을 하려 합니다.<br>
						바쁘신 중에도 저희의 소중한 순간을<br>
						함께해 주시는 모든 분들께 감사드립니다.<br><br>
						
						앞으로도 변함없는 사랑과 격려<br>
						부탁드립니다.
					</p>
				</div>
			</section>

			<!-- Phase 3: 자주 포함 요소 -->

			<!-- 10. 달력/카운트다운 -->
			<section class="px-6 py-8">
				<h3 class="text-xl font-semibold text-center mb-6 text-rose-800">결혼식까지</h3>
				
				<div class="text-center bg-gradient-to-b from-rose-100 to-rose-50 rounded-lg p-6">
					<div class="text-3xl font-bold text-rose-800 mb-2">
						[D-30]
					</div>
					<p class="text-gray-600">2024년 10월 25일까지</p>
					
					<!-- 간단한 달력 표시 -->
					<div class="mt-6 bg-white rounded-lg p-4">
						<p class="text-sm text-gray-500 mb-2">2024년 10월</p>
						<div class="w-full h-24 bg-gray-100 rounded flex items-center justify-center">
							<span class="text-gray-500">[달력 위젯]</span>
						</div>
					</div>
				</div>
			</section>

			<!-- 11. 교통편 안내 -->
			<section class="px-6 py-8">
				<h3 class="text-xl font-semibold text-center mb-6 text-rose-800">교통편 안내</h3>
				
				<div class="space-y-4">
					<!-- 지하철 -->
					<div class="bg-blue-50 rounded-lg p-4">
						<h4 class="font-semibold mb-2 text-blue-800 flex items-center">
							🚇 지하철
						</h4>
						<p class="text-sm text-gray-700">
							2호선 강남역 3번 출구 도보 5분<br>
							9호선 신논현역 1번 출구 도보 3분
						</p>
					</div>
					
					<!-- 버스 -->
					<div class="bg-green-50 rounded-lg p-4">
						<h4 class="font-semibold mb-2 text-green-800 flex items-center">
							🚌 버스
						</h4>
						<p class="text-sm text-gray-700">
							강남 02, 421, 463번<br>
							'강남역' 하차 후 도보 5분
						</p>
					</div>
					
					<!-- 주차 -->
					<div class="bg-purple-50 rounded-lg p-4">
						<h4 class="font-semibold mb-2 text-purple-800 flex items-center">
							🚗 주차
						</h4>
						<p class="text-sm text-gray-700">
							지하 1층~3층 (3시간 무료)<br>
							발렛파킹 가능 (1만원)
						</p>
					</div>
				</div>
			</section>

			<!-- 12. 배경음악 -->
			<section class="px-6 py-8">
				<h3 class="text-xl font-semibold text-center mb-6 text-rose-800">함께 들어요</h3>
				
				<div class="bg-gradient-to-r from-rose-100 to-pink-100 rounded-lg p-6 text-center">
					<div class="w-full h-16 bg-white rounded-lg flex items-center justify-center mb-4">
						<span class="text-gray-500">[음악 플레이어]</span>
					</div>
					<p class="text-sm text-gray-700 mb-2">우리의 특별한 노래</p>
					<p class="text-xs text-gray-500">"All of Me" - John Legend</p>
					
					<div class="flex justify-center gap-4 mt-4">
						<button class="bg-white rounded-full w-12 h-12 flex items-center justify-center shadow">
							▶️
						</button>
						<button class="bg-white rounded-full w-12 h-12 flex items-center justify-center shadow">
							🔇
						</button>
					</div>
				</div>
			</section>

			<!-- Phase 4: 선택적 요소 -->

			<!-- 13. 연애 스토리 -->
			<section class="px-6 py-8">
				<h3 class="text-xl font-semibold text-center mb-6 text-rose-800">우리의 이야기</h3>
				
				<div class="space-y-6">
					<!-- 타임라인 아이템 -->
					<div class="flex gap-4">
						<div class="w-12 h-12 bg-rose-200 rounded-full flex items-center justify-center flex-shrink-0">
							💕
						</div>
						<div>
							<h4 class="font-semibold text-rose-800">2019.03 첫 만남</h4>
							<p class="text-sm text-gray-600 mt-1">대학교 동아리에서 처음 만났어요</p>
						</div>
					</div>
					
					<div class="flex gap-4">
						<div class="w-12 h-12 bg-pink-200 rounded-full flex items-center justify-center flex-shrink-0">
							💖
						</div>
						<div>
							<h4 class="font-semibold text-pink-800">2020.05 첫 고백</h4>
							<p class="text-sm text-gray-600 mt-1">코로나로 힘든 시기, 서로가 힘이 되어주었어요</p>
						</div>
					</div>
					
					<div class="flex gap-4">
						<div class="w-12 h-12 bg-red-200 rounded-full flex items-center justify-center flex-shrink-0">
							💍
						</div>
						<div>
							<h4 class="font-semibold text-red-800">2022.12 프로포즈</h4>
							<p class="text-sm text-gray-600 mt-1">눈 내리는 겨울날, 특별한 순간이었어요</p>
						</div>
					</div>
					
					<div class="flex gap-4">
						<div class="w-12 h-12 bg-rose-300 rounded-full flex items-center justify-center flex-shrink-0">
							💒
						</div>
						<div>
							<h4 class="font-semibold text-rose-800">2024.10 결혼</h4>
							<p class="text-sm text-gray-600 mt-1">드디어 평생을 함께하게 되었습니다</p>
						</div>
					</div>
				</div>
			</section>

			<!-- 푸터 -->
			<footer class="px-6 py-8 text-center bg-rose-100">
				<p class="text-sm text-gray-600 mb-2">
					김철수 ♥ 이영희
				</p>
				<p class="text-xs text-gray-500">
					2024년 10월 25일 토요일 오후 2시<br>
					서울웨딩홀 3층 그레이스홀
				</p>
			</footer>

		</main>
		
		<style>
			/* 커튼 효과 스타일 */
			.wrinkle-line {
				transition: all 0.1s ease-out;
			}
			
			.wrinkle-visible {
				opacity: 0.7 !important;
			}
		</style>

		<script is:inline>
			class CurtainEffect {
				constructor() {
					this.viewportWidth = window.innerWidth;
					this.viewportHeight = window.innerHeight;
					this.centerX = this.viewportWidth / 2;
					this.centerY = this.viewportHeight * 2 / 3; // 아래서 1/3 지점 (위에서 2/3 지점)
					
					// 각 페이즈별 독립적 시간 설정
					this.initialWaitDuration = 1000; // 초기 1초 대기
					this.phase0Duration = 500; // 초기 회색 가로줄 생성 (500ms)
					this.phase0WaitDuration = 1000; // 휴면 시간 (1000ms)
					this.phase1Duration = 400; // 꼭지점 이동 (400ms)
					this.phase2Duration = 300; // 대기 시간 (300ms)
					this.phase3Duration = 2000; // 커튼 이동 + 주름 (2초)
					this.totalDuration = this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration + this.phase1Duration + this.phase2Duration + this.phase3Duration;
					
					this.startTime = null;
					this.wrinkleLines = [];
					
					this.init();
				}
				
				init() {
					this.setupCurtains();
					this.setupWrinkles();
					this.setupInitialGrayLines();
					this.startAnimation();
				}
				
				setupCurtains() {
					const topLeft = document.getElementById('curtain-top-left');
					const topRight = document.getElementById('curtain-top-right');
					const bottomLeft = document.getElementById('curtain-bottom-left');
					const bottomRight = document.getElementById('curtain-bottom-right');
					
					// 초기 위치 설정 - 화면 전체를 덮음
					topLeft.style.left = '0px';
					topLeft.style.top = '0px';
					topLeft.style.width = this.centerX + 'px';
					topLeft.style.height = this.centerY + 'px';
					
					topRight.style.left = this.centerX + 'px';
					topRight.style.top = '0px';
					topRight.style.width = (this.viewportWidth - this.centerX) + 'px';
					topRight.style.height = this.centerY + 'px';
					
					bottomLeft.style.left = '0px';
					bottomLeft.style.top = this.centerY + 'px';
					bottomLeft.style.width = this.centerX + 'px';
					bottomLeft.style.height = (this.viewportHeight - this.centerY) + 'px';
					
					bottomRight.style.left = this.centerX + 'px';
					bottomRight.style.top = this.centerY + 'px';
					bottomRight.style.width = (this.viewportWidth - this.centerX) + 'px';
					bottomRight.style.height = (this.viewportHeight - this.centerY) + 'px';
				}
				
				setupWrinkles() {
					const container = document.getElementById('wrinkles-container');
					
					if (!container) {
						return;
					}
					
					// 각 사각형마다 5개씩 세로선 생성 (총 20개)
					const sections = [
						{ id: 'top-left', x: 0, y: 0, w: this.centerX, h: this.centerY },
						{ id: 'top-right', x: this.centerX, y: 0, w: this.viewportWidth - this.centerX, h: this.centerY },
						{ id: 'bottom-left', x: 0, y: this.centerY, w: this.centerX, h: this.viewportHeight - this.centerY },
						{ id: 'bottom-right', x: this.centerX, y: this.centerY, w: this.viewportWidth - this.centerX, h: this.viewportHeight - this.centerY }
					];
					
					let totalCreated = 0;
					sections.forEach(section => {
						for (let i = 1; i <= 5; i++) {
							const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
							line.classList.add('wrinkle-line');
							line.dataset.section = section.id;
							line.dataset.index = i;
							
							// 각 섹션을 6등분하여 5개 선 배치 (양끝 제외)
							const isLeftSection = section.id.includes('left');
							const sectionWidth = isLeftSection ? this.centerX : (this.viewportWidth - this.centerX);
							const spacing = sectionWidth / 6; // 6등분
							
							const x = isLeftSection ? 
								(spacing * i) : // 왼쪽 섹션: spacing, 2*spacing, 3*spacing, 4*spacing, 5*spacing
								(this.centerX + (spacing * i)); // 오른쪽 섹션: centerX + spacing, centerX + 2*spacing, ...
							line.setAttribute('x1', x);
							line.setAttribute('y1', section.y);
							line.setAttribute('x2', x);
							line.setAttribute('y2', section.y + section.h);
							line.setAttribute('stroke', '#d1d5db');
							line.setAttribute('stroke-width', '3');
							line.setAttribute('opacity', '0');
							
							// 초기 상태는 보이지 않음
							
							container.appendChild(line);
							this.wrinkleLines.push({
								element: line,
								section: section.id,
								index: i,
								originalX: x,
								originalY: section.y,
								originalHeight: section.h,
								activated: false,
								screenPointMoving: false, // 화면 맞닿는 점 이동 여부
								activationCurtainMove: null, // 주름이 활성화될 때의 커튼 이동량 저장
								rotationEndCoords: null // 회전이 끝날 때의 좌표 저장 {x1, y1, x2, y2}
							});
							totalCreated++;
						}
					});
					
				}
				
				setupInitialGrayLines() {
					const leftLine = document.getElementById('initial-gray-line-left');
					const rightLine = document.getElementById('initial-gray-line-right');
					
					// 초기 위치 설정: 화면을 관통하는 띠 (커튼 고정용)
					// 왼쪽 반: 화면 왼쪽 끝부터 중심까지
					leftLine.style.left = '0px';
					leftLine.style.top = this.centerY + 'px';
					leftLine.style.width = this.centerX + 'px';
					
					// 오른쪽 반: 중심부터 화면 오른쪽 끝까지
					rightLine.style.left = this.centerX + 'px';
					rightLine.style.top = this.centerY + 'px';
					rightLine.style.width = (this.viewportWidth - this.centerX) + 'px';
				}
				
				startAnimation() {
					this.startTime = performance.now();
					this.animate();
				}
				
				animate() {
					const currentTime = performance.now();
					const elapsed = currentTime - this.startTime;
					
					// 현재 페이즈와 해당 페이즈 내 진행률 계산
					let currentPhase, phaseProgress;
					
					if (elapsed <= this.initialWaitDuration) {
						// 초기 1초 대기
						currentPhase = -1;
						phaseProgress = elapsed / this.initialWaitDuration;
					} else if (elapsed <= this.initialWaitDuration + this.phase0Duration) {
						// 페이즈 0: 초기 회색 가로줄 생성
						currentPhase = 0;
						phaseProgress = (elapsed - this.initialWaitDuration) / this.phase0Duration;
					} else if (elapsed <= this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration) {
						// 페이즈 0.5: 휴면 (대기)
						currentPhase = 0.5;
						phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration) / this.phase0WaitDuration;
					} else if (elapsed <= this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration + this.phase1Duration) {
						// 페이즈 1: 꼭지점 이동
						currentPhase = 1;
						phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration - this.phase0WaitDuration) / this.phase1Duration;
					} else if (elapsed <= this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration + this.phase1Duration + this.phase2Duration) {
						// 페이즈 2: 대기
						currentPhase = 2;
						phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration - this.phase0WaitDuration - this.phase1Duration) / this.phase2Duration;
					} else if (elapsed <= this.totalDuration) {
						// 페이즈 3: 커튼 이동 + 주름
						currentPhase = 3;
						phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration - this.phase0WaitDuration - this.phase1Duration - this.phase2Duration) / this.phase3Duration;
					} else {
						// 애니메이션 완료
						currentPhase = 4;
						phaseProgress = 1;
					}
					
					this.updateInitialOverlay(currentPhase, phaseProgress);
					this.updateInitialGrayLines(currentPhase, phaseProgress);
					this.updateCurtains(currentPhase, phaseProgress);
					this.updateWrinkles(currentPhase, phaseProgress);
					
					if (currentPhase < 4) {
						requestAnimationFrame(() => this.animate());
					} else {
						this.cleanup();
					}
				}
				
				updateInitialOverlay(currentPhase, phaseProgress) {
					const initialOverlay = document.getElementById('initial-overlay');
					
					// 오버레이가 존재할 때만 처리
					if (!initialOverlay) return;
					
					if (currentPhase === -1) {
						// 초기 1초 대기: 투명도 0에서 1로 서서히 변화
						const opacity = this.easeOutCubic(phaseProgress);
						initialOverlay.style.opacity = opacity;
						
					} else if (currentPhase >= 0) {
						// 페이즈 0 이후: 완전히 보임 상태 유지
						initialOverlay.style.opacity = '1';
					}
				}
				
				updateInitialGrayLines(currentPhase, phaseProgress) {
					const leftLine = document.getElementById('initial-gray-line-left');
					const rightLine = document.getElementById('initial-gray-line-right');
					
					if (currentPhase === -1) {
						// 초기 1초 대기: 아무것도 표시하지 않음
						leftLine.style.opacity = '0';
						rightLine.style.opacity = '0';
						
					} else if (currentPhase === 0) {
						// 페이즈 0: 회색 가로줄 페이드인 (200ms)
						const opacity = this.easeOutCubic(phaseProgress);
						leftLine.style.opacity = opacity;
						rightLine.style.opacity = opacity;
						
					} else if (currentPhase === 0.5) {
						// 페이즈 0.5: 휴면 상태 (300ms) - 완전 보임
						leftLine.style.opacity = '1';
						rightLine.style.opacity = '1';
						
					} else if (currentPhase === 1) {
						// 페이즈 1: 꼭지점 이동과 함께 띠가 중앙에서 벌어짐 (찢어지는 효과)
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const cornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
						
						// 왼쪽 띠: 중심에서 왼쪽으로 벌어짐
						leftLine.style.left = '0px';
						leftLine.style.width = (this.centerX - cornerMove) + 'px';
						
						// 오른쪽 띠: 중심에서 오른쪽으로 벌어짐
						rightLine.style.left = (this.centerX + cornerMove) + 'px';
						rightLine.style.width = (this.viewportWidth - this.centerX - cornerMove) + 'px';
						
					} else if (currentPhase === 2) {
						// 페이즈 2: 대기 - 찢어진 상태 유지
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						
						leftLine.style.left = '0px';
						leftLine.style.width = (this.centerX - maxCornerMove) + 'px';
						leftLine.style.opacity = '1';
						
						rightLine.style.left = (this.centerX + maxCornerMove) + 'px';
						rightLine.style.width = (this.viewportWidth - this.centerX - maxCornerMove) + 'px';
						rightLine.style.opacity = '1';
						
					} else if (currentPhase === 3) {
						// 페이즈 3: 커튼과 함께 띠도 좌우로 이동
						const maxMove = this.viewportWidth * 1.5;
						const move = maxMove * this.easeInCubic(phaseProgress);
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						
						// 왼쪽 띠: 왼쪽으로 이동
						leftLine.style.transform = `translateX(${-move}px)`;
						leftLine.style.left = '0px';
						leftLine.style.width = (this.centerX - maxCornerMove) + 'px';
						leftLine.style.opacity = '1';
						
						// 오른쪽 띠: 오른쪽으로 이동
						rightLine.style.transform = `translateX(${move}px)`;
						rightLine.style.left = (this.centerX + maxCornerMove) + 'px';
						rightLine.style.width = (this.viewportWidth - this.centerX - maxCornerMove) + 'px';
						rightLine.style.opacity = '1';
					}
				}
				
				updateCurtains(currentPhase, phaseProgress) {
					const topLeft = document.getElementById('curtain-top-left');
					const topRight = document.getElementById('curtain-top-right');
					const bottomLeft = document.getElementById('curtain-bottom-left');
					const bottomRight = document.getElementById('curtain-bottom-right');
					const initialOverlay = document.getElementById('initial-overlay');
					
					if (currentPhase === 1) {
						// 커튼(네모4개) 생성 시점에서 흰색 덮개 삭제
						if (initialOverlay) {
							initialOverlay.remove();
						}
						// 페이즈 1: 꼭지점만 이동 (400ms)
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const cornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
						
						// 왼쪽 위: 오른쪽 아래 꼭지점이 왼쪽으로
						topLeft.style.clipPath = `polygon(0% 0%, 100% 0%, ${100 - (cornerMove/this.centerX)*100}% 100%, 0% 100%)`;
						
						// 오른쪽 위: 왼쪽 아래 꼭지점이 오른쪽으로
						topRight.style.clipPath = `polygon(${(cornerMove/(this.viewportWidth-this.centerX))*100}% 100%, 100% 100%, 100% 0%, 0% 0%)`;
						
						// 왼쪽 아래: 오른쪽 위 꼭지점이 왼쪽으로
						bottomLeft.style.clipPath = `polygon(0% 0%, ${100 - (cornerMove/this.centerX)*100}% 0%, 100% 100%, 0% 100%)`;
						
						// 오른쪽 아래: 왼쪽 위 꼭지점이 오른쪽으로
						bottomRight.style.clipPath = `polygon(${(cornerMove/(this.viewportWidth-this.centerX))*100}% 0%, 100% 0%, 100% 100%, 0% 100%)`;
						
					} else if (currentPhase === 2) {
						// 페이즈 2: 대기 (300ms) - clipPath 상태 유지
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						
						topLeft.style.clipPath = `polygon(0% 0%, 100% 0%, ${100 - (maxCornerMove/this.centerX)*100}% 100%, 0% 100%)`;
						topRight.style.clipPath = `polygon(${(maxCornerMove/(this.viewportWidth-this.centerX))*100}% 100%, 100% 100%, 100% 0%, 0% 0%)`;
						bottomLeft.style.clipPath = `polygon(0% 0%, ${100 - (maxCornerMove/this.centerX)*100}% 0%, 100% 100%, 0% 100%)`;
						bottomRight.style.clipPath = `polygon(${(maxCornerMove/(this.viewportWidth-this.centerX))*100}% 0%, 100% 0%, 100% 100%, 0% 100%)`;
						
					} else if (currentPhase === 3) {
						// 페이즈 3: 전체 이동 (1600ms)
						const maxMove = this.viewportWidth * 1.5;
						const move = maxMove * this.easeInCubic(phaseProgress);
						
						// 각 사각형을 x축 방향으로만 이동
						topLeft.style.transform = `translateX(${-move}px)`;
						topRight.style.transform = `translateX(${move}px)`;
						bottomLeft.style.transform = `translateX(${-move}px)`;
						bottomRight.style.transform = `translateX(${move}px)`;
					}
				}
				
				updateWrinkles(currentPhase, phaseProgress) {
					let leftCornerX = null;
					let rightCornerX = null;
					
					if (currentPhase === 1) {
						// 페이즈 1: clipPath 기반 꼭지점 이동
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const currentCornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
						
						leftCornerX = this.centerX - currentCornerMove;  
						rightCornerX = this.centerX + currentCornerMove; 
						
					} else if (currentPhase >= 3) {
						// 페이즈 3: transform 기반 전체 이동
						// 페이즈 1 완료 시의 최종 꼭지점 위치
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const finalCornerMove = maxCornerMove; // 페이즈 1 완료 시점
						
						// 페이즈 3에서의 transform 이동량
						const maxMove = this.viewportWidth * 1.5;
						const currentMove = maxMove * this.easeInCubic(phaseProgress);
						
						// 최종 꼭지점 위치 + transform 이동량
						leftCornerX = (this.centerX - finalCornerMove) - currentMove;
						rightCornerX = (this.centerX + finalCornerMove) + currentMove;
					}
					
					if (leftCornerX !== null && rightCornerX !== null) {
						this.wrinkleLines.forEach((wrinkle, index) => {
							if (!wrinkle.activated) {
								const wrinkleX = wrinkle.originalX;
								const isLeftSection = wrinkle.section.includes('left');
								
								// 주름 간격(x) 계산
								const sectionWidth = isLeftSection ? this.centerX : (this.viewportWidth - this.centerX);
								const spacing = sectionWidth / 6; // x = spacing
								const earlyOffset = spacing / 5; // x/5
								
								// 꼭지점이 주름 위치에 (x/5) 전에 도달했을 때 활성화
								const shouldActivate = isLeftSection ? 
									(leftCornerX <= (wrinkleX + earlyOffset)) :   // 왼쪽: 커튼이 주름보다 (x/5) 오른쪽에 있을 때
									(rightCornerX >= (wrinkleX - earlyOffset));   // 오른쪽: 커튼이 주름보다 (x/5) 왼쪽에 있을 때
								
								if (shouldActivate) {
									wrinkle.element.classList.add('wrinkle-visible');
									wrinkle.element.setAttribute('opacity', '0.7');
									wrinkle.activated = true;
								}
							}
							
							// 활성화된 주름들 처리
							if (wrinkle.activated) {
								// 화면 맞닿는 점 이동 조건 확인
								if (!wrinkle.screenPointMoving) {
									const isLeftSection = wrinkle.section.includes('left');
									const sectionWidth = isLeftSection ? this.centerX : (this.viewportWidth - this.centerX);
									const spacing = sectionWidth / 6; // x = 주름 간격
									
									// 중심에 가까운 순서대로 n 계산 (0부터 시작)
									const n = isLeftSection ? 
										(5 - wrinkle.index) :  // 왼쪽: left-5가 n=0, left-1이 n=4
										(wrinkle.index - 1);   // 오른쪽: right-1이 n=0, right-5가 n=4
									
									// 커튼 이동점 (leftCornerX 또는 rightCornerX)
									const curtainMovingX = isLeftSection ? leftCornerX : rightCornerX;
									const curtainTotalMove = Math.abs(curtainMovingX - this.centerX);
									
									// 주름이 활성화될 때의 커튼 이동량 저장
									if (wrinkle.activationCurtainMove === null) {
										wrinkle.activationCurtainMove = curtainTotalMove;
									}
									
									// 회전 정지 조건: 활성화 후 x*(6-n)/6만큼 추가 이동
									const additionalMoveNeeded = spacing * (6 - n) / 6; // x*(6-n)/6
									const rotationStopMove = wrinkle.activationCurtainMove + additionalMoveNeeded;
									
									// 조건 달성 시 화면 점 이동 시작
									if (curtainTotalMove >= rotationStopMove) {
										
										// 회전이 끝나는 시점의 좌표를 화면점/커튼점으로 명확히 구분해서 저장
										const isTopSection = wrinkle.section.includes('top');
										wrinkle.rotationEndCoords = {
											screenX: isTopSection ? parseFloat(wrinkle.element.getAttribute('x1')) : parseFloat(wrinkle.element.getAttribute('x2')),
											screenY: isTopSection ? parseFloat(wrinkle.element.getAttribute('y1')) : parseFloat(wrinkle.element.getAttribute('y2')),
											curtainX: isTopSection ? parseFloat(wrinkle.element.getAttribute('x2')) : parseFloat(wrinkle.element.getAttribute('x1')),
											curtainY: isTopSection ? parseFloat(wrinkle.element.getAttribute('y2')) : parseFloat(wrinkle.element.getAttribute('y1'))
										};
										
										// 이동 시작 시점의 커튼 위치 저장
										const isLeftSection = wrinkle.section.includes('left');
										wrinkle.linearStartCurtainX = isLeftSection ? leftCornerX : rightCornerX;
										wrinkle.screenPointMoving = true;
									}
								}
								
								// 주름 업데이트 (회전 또는 이동)
								if (wrinkle.screenPointMoving) {
									// 선형 이동 모드
									this.updateWrinkleLinearMovement(wrinkle, currentPhase, phaseProgress);
								} else {
									// 회전 모드
									this.updateWrinkleTilt(wrinkle, currentPhase, phaseProgress);
								}
							}
						});
					}
				}
				
				updateWrinkleTilt(wrinkle, currentPhase, phaseProgress) {
					const isLeftSection = wrinkle.section.includes('left');
					const isTopSection = wrinkle.section.includes('top');
					
					// 회전 모드: 화면 맞닿는 점 고정
					const fixedX = wrinkle.originalX;
					const fixedY = isTopSection ? wrinkle.originalY : (wrinkle.originalY + wrinkle.originalHeight); // top이면 위점 고정, bottom이면 아래점 고정
					
					// 꼭지점 위치 계산
					let cornerX, cornerY;
					
					if (currentPhase === 1) {
						// 페이즈 1: clipPath 기반 꼭지점 이동
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const currentCornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
						
						cornerX = isLeftSection ? (this.centerX - currentCornerMove) : (this.centerX + currentCornerMove);
						cornerY = this.centerY;
						
					} else if (currentPhase >= 3) {
						// 페이즈 3: transform 기반 전체 이동
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const finalCornerMove = maxCornerMove;
						
						const maxMove = this.viewportWidth * 1.5;
						const currentMove = maxMove * this.easeInCubic(phaseProgress);
						
						cornerX = isLeftSection ? 
							((this.centerX - finalCornerMove) - currentMove) : 
							((this.centerX + finalCornerMove) + currentMove);
						cornerY = this.centerY;
					}
					
					if (cornerX !== undefined && cornerY !== undefined) {
						// 이동점은 반드시 꼭지점 이동경로(y = this.centerY)에 맞닿아야 함
						const movingX = cornerX;
						const movingY = this.centerY; // 꼭지점 이동경로인 중앙 가로선에 고정
						
						// 고정점에서 이동점까지의 실제 거리 계산 (길이가 늘어남)
						const dx = movingX - fixedX;
						const dy = movingY - fixedY;
						const currentLength = Math.sqrt(dx * dx + dy * dy);
						
						// 원래 섹션 높이 (회전하지 않을 때)
						const originalSectionHeight = isTopSection ? this.centerY : (this.viewportHeight - this.centerY);
						
						// 기본 회전각 c 계산 (1페이즈 완료 시 커튼 기울기)
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const basicAngle = Math.atan(maxCornerMove / originalSectionHeight);
						
						// 현재 회전각 계산 (꼭지점 이동에 비례)
						const currentCornerMove = Math.abs(cornerX - this.centerX);
						const currentAngle = Math.atan(currentCornerMove / originalSectionHeight);
						
						// 최대 회전각 y는 기본각의 3배로 설정
						const maxAngle = basicAngle * 3;
						const rotationAngle = Math.min(currentAngle, maxAngle);
						
						// 실제 좌표는 이미 계산됨 (이동점이 꼭지점 경로에 맞닿음)
						const newMovingX = movingX;
						const newMovingY = movingY;
						
						// SVG 라인 업데이트
						if (isTopSection) {
							// top 섹션: 위점 고정, 아래점 이동
							wrinkle.element.setAttribute('x1', fixedX);
							wrinkle.element.setAttribute('y1', fixedY);
							wrinkle.element.setAttribute('x2', newMovingX);
							wrinkle.element.setAttribute('y2', newMovingY);
						} else {
							// bottom 섹션: 아래점 고정, 위점 이동
							wrinkle.element.setAttribute('x1', newMovingX);
							wrinkle.element.setAttribute('y1', newMovingY);
							wrinkle.element.setAttribute('x2', fixedX);
							wrinkle.element.setAttribute('y2', fixedY);
						}
					}
				}
				
				updateWrinkleLinearMovement(wrinkle, currentPhase, phaseProgress) {
					const isLeftSection = wrinkle.section.includes('left');
					const isTopSection = wrinkle.section.includes('top');
					
					// 회전이 끝났을 때의 좌표가 저장되어 있는지 확인
					if (!wrinkle.rotationEndCoords) {
						// 저장된 좌표가 없으면 현재 좌표를 화면점/커튼점으로 구분해서 저장
						wrinkle.rotationEndCoords = {
							screenX: isTopSection ? parseFloat(wrinkle.element.getAttribute('x1')) : parseFloat(wrinkle.element.getAttribute('x2')),
							screenY: isTopSection ? parseFloat(wrinkle.element.getAttribute('y1')) : parseFloat(wrinkle.element.getAttribute('y2')),
							curtainX: isTopSection ? parseFloat(wrinkle.element.getAttribute('x2')) : parseFloat(wrinkle.element.getAttribute('x1')),
							curtainY: isTopSection ? parseFloat(wrinkle.element.getAttribute('y2')) : parseFloat(wrinkle.element.getAttribute('y1'))
						};
					}
					
					// 꼭지점 위치 계산 (커튼 이동점)
					let cornerX, cornerY;
					
					if (currentPhase === 1) {
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const currentCornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
						cornerX = isLeftSection ? (this.centerX - currentCornerMove) : (this.centerX + currentCornerMove);
						cornerY = this.centerY;
					} else if (currentPhase >= 3) {
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const finalCornerMove = maxCornerMove;
						const maxMove = this.viewportWidth * 1.5;
						const currentMove = maxMove * this.easeInCubic(phaseProgress);
						cornerX = isLeftSection ? 
							((this.centerX - finalCornerMove) - currentMove) : 
							((this.centerX + finalCornerMove) + currentMove);
						cornerY = this.centerY;
					}
					
					if (cornerX !== undefined && cornerY !== undefined) {
						// 화면 맞닿는 점: 회전 종료 시점 위치에서 커튼과 같은 속도로 이동
						const direction = isLeftSection ? -1 : 1;
						const maxMove = this.viewportWidth * 1.5;
						// 커튼의 실제 이동량 계산
					const currentCurtainX = isLeftSection ? 
						(cornerX || (this.centerX - Math.min(this.centerX, this.centerY) * 0.2)) : 
						(cornerX || (this.centerX + Math.min(this.centerX, this.centerY) * 0.2));
					const currentMove = Math.abs(currentCurtainX - wrinkle.linearStartCurtainX);
						
						// 회전 종료 시점의 화면 맞닿는 점에서 추가 이동
						const screenMovingX = wrinkle.rotationEndCoords.screenX + (direction * currentMove);
						const screenMovingY = wrinkle.rotationEndCoords.screenY;
						
						
						// SVG 라인 업데이트: 회전된 상태를 유지하면서 이동
						if (isTopSection) {
							// top 섹션: x1=화면점, x2=커튼점
							wrinkle.element.setAttribute('x1', screenMovingX);
							wrinkle.element.setAttribute('y1', screenMovingY);
							wrinkle.element.setAttribute('x2', cornerX);
							wrinkle.element.setAttribute('y2', cornerY);
						} else {
							// bottom 섹션: x1=커튼점, x2=화면점
							wrinkle.element.setAttribute('x1', cornerX);
							wrinkle.element.setAttribute('y1', cornerY);
							wrinkle.element.setAttribute('x2', screenMovingX);
							wrinkle.element.setAttribute('y2', screenMovingY);
						}
						
					}
				}
				
				cleanup() {
					// 애니메이션 완료 후 모든 커튼 요소 제거
					const overlay = document.getElementById('curtain-overlay');
					overlay.style.opacity = '0';
					setTimeout(() => {
						overlay.remove();
					}, 300);
				}
				
				// 이징 함수들
				easeOutCubic(t) {
					return 1 - Math.pow(1 - t, 3);
				}
				
				easeInCubic(t) {
					return t * t * t;
				}
				
				easeOutQuad(t) {
					return 1 - (1 - t) * (1 - t);
				}
			}
			
			// 페이지 로드 시 커튼 효과 시작
			window.addEventListener('load', () => {
				window.curtainEffectInstance = new CurtainEffect();
			});
		</script>
		
	</body>
</html>
