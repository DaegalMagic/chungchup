<!DOCTYPE html><html lang="ko" data-astro-cid-j7pv25f6> <head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>김철수 ♥ 이영희 결혼식</title><meta name="description" content="김철수와 이영희의 결혼식에 초대합니다"><link rel="stylesheet" href="/_astro/index.DV-eWruZ.css"><!-- 새 배포 강제: 2025-01-14 --></head> <body class="text-gray-800 font-sans bg-rose-50" data-astro-cid-j7pv25f6> <!-- 커튼 효과 요소들 --> <div id="curtain-overlay" class="fixed inset-0 z-50 pointer-events-none" data-curtain="true" style="display: block;" data-astro-cid-j7pv25f6> <!-- 검은 화면 (본 화면을 가리는 용도) --> <div id="black-screen" class="absolute bg-black" style="z-index: 49; display: block; position: absolute; inset: 0; background-color: black; opacity: 1;" data-curtain="black-screen" data-astro-cid-j7pv25f6><!-- 검은 화면 --></div> <!-- 초기 전체 화면 덮개 --> <div id="initial-overlay" class="absolute bg-white" style="z-index: 50; display: block; position: absolute; inset: 0; background-color: white; opacity: 0;" data-curtain="initial-overlay" data-astro-cid-j7pv25f6><!-- 초기 화면 덮개 --></div> <!-- 4개의 하얀 사각형 --> <div id="curtain-top-left" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel" data-astro-cid-j7pv25f6><!-- 커튼 패널 --></div> <div id="curtain-top-right" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel" data-astro-cid-j7pv25f6><!-- 커튼 패널 --></div> <div id="curtain-bottom-left" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel" data-astro-cid-j7pv25f6><!-- 커튼 패널 --></div> <div id="curtain-bottom-right" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel" data-astro-cid-j7pv25f6><!-- 커튼 패널 --></div> <!-- 초기 회색 가로줄 --> <div id="initial-gray-line-left" class="absolute bg-gray-400" style="z-index: 53; display: block; height: 2px; opacity: 0;" data-curtain="initial-line" data-astro-cid-j7pv25f6><!-- 초기 가로줄 왼쪽 --></div> <div id="initial-gray-line-right" class="absolute bg-gray-400" style="z-index: 53; display: block; height: 2px; opacity: 0;" data-curtain="initial-line" data-astro-cid-j7pv25f6><!-- 초기 가로줄 오른쪽 --></div> <!-- 20개의 주름 세로선 --> <svg id="wrinkles-container" style="z-index: 52; display: block; position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none;" data-curtain="wrinkles" data-astro-cid-j7pv25f6> <!-- 주름 선들이 여기에 동적으로 추가됩니다 --> </svg> </div> <main class="max-w-md mx-auto bg-white min-h-screen" data-astro-cid-j7pv25f6> <!-- Phase 1: 필수 요소 --> <!-- 1. 신랑신부 정보 + 2. 결혼식 정보 --> <section class="text-center py-12 px-6 bg-gradient-to-b from-rose-100 to-white" data-astro-cid-j7pv25f6> <div class="mb-8" data-astro-cid-j7pv25f6> <h1 class="text-3xl font-bold text-rose-800 mb-2" data-astro-cid-j7pv25f6>
김철수 ♥ 이영희
</h1> <p class="text-sm text-gray-600 mb-4" data-astro-cid-j7pv25f6>
김○○ · 박○○ 의 장남 철수<br data-astro-cid-j7pv25f6>
이○○ · 최○○ 의 장녀 영희
</p> </div> <div class="text-center" data-astro-cid-j7pv25f6> <h2 class="text-xl font-semibold text-gray-700 mb-2" data-astro-cid-j7pv25f6>
2024년 10월 25일 토요일
</h2> <p class="text-lg text-rose-700" data-astro-cid-j7pv25f6>
오후 2시
</p> </div> </section> <!-- 6. 메인 사진 --> <section class="px-6 py-8" data-astro-cid-j7pv25f6> <div class="w-full h-80 bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300" data-astro-cid-j7pv25f6> <span class="text-gray-500 text-lg font-medium" data-astro-cid-j7pv25f6>[메인 웨딩사진]</span> </div> </section> <!-- 5. 기본 인사말 --> <section class="px-6 py-8 text-center" data-astro-cid-j7pv25f6> <div class="bg-rose-50 rounded-lg p-6" data-astro-cid-j7pv25f6> <h3 class="text-lg font-semibold mb-4 text-rose-800" data-astro-cid-j7pv25f6>소중한 분들께</h3> <p class="text-gray-700 leading-relaxed" data-astro-cid-j7pv25f6>
[기본 인사말]<br data-astro-cid-j7pv25f6>
저희 두 사람이 사랑의 결실을 맺게 되었습니다.<br data-astro-cid-j7pv25f6>
소중한 분들과 함께 새로운 시작을 하고자 합니다.<br data-astro-cid-j7pv25f6>
바쁘신 중에도 참석하시어 축복해 주시면<br data-astro-cid-j7pv25f6>
더없는 기쁨이겠습니다.
</p> </div> </section> <!-- 3. 장소 정보 --> <section class="px-6 py-8" data-astro-cid-j7pv25f6> <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>오시는 길</h3> <!-- 지도 영역 --> <div class="w-full h-48 bg-gray-200 rounded-lg mb-4 flex items-center justify-center border-2 border-dashed border-gray-300" data-astro-cid-j7pv25f6> <span class="text-gray-500 text-lg font-medium" data-astro-cid-j7pv25f6>[카카오맵]</span> </div> <div class="text-center" data-astro-cid-j7pv25f6> <h4 class="text-lg font-semibold mb-2" data-astro-cid-j7pv25f6>서울웨딩홀</h4> <p class="text-gray-600 mb-2" data-astro-cid-j7pv25f6>3층 그레이스홀</p> <p class="text-sm text-gray-500" data-astro-cid-j7pv25f6>서울시 강남구 테헤란로 123</p> </div> </section> <!-- 4. 연락처 --> <section class="px-6 py-8" data-astro-cid-j7pv25f6> <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>연락처</h3> <div class="grid grid-cols-2 gap-4" data-astro-cid-j7pv25f6> <!-- 신랑측 --> <div class="text-center bg-blue-50 rounded-lg p-4" data-astro-cid-j7pv25f6> <h4 class="font-semibold mb-3 text-blue-800" data-astro-cid-j7pv25f6>신랑측</h4> <div class="space-y-2 text-sm" data-astro-cid-j7pv25f6> <div data-astro-cid-j7pv25f6> <p class="font-medium" data-astro-cid-j7pv25f6>김철수</p> <button class="text-blue-600 underline" data-astro-cid-j7pv25f6>010-1234-5678</button> </div> <div data-astro-cid-j7pv25f6> <p class="font-medium" data-astro-cid-j7pv25f6>아버지 김○○</p> <button class="text-blue-600 underline" data-astro-cid-j7pv25f6>010-1111-2222</button> </div> <div data-astro-cid-j7pv25f6> <p class="font-medium" data-astro-cid-j7pv25f6>어머니 박○○</p> <button class="text-blue-600 underline" data-astro-cid-j7pv25f6>010-3333-4444</button> </div> </div> </div> <!-- 신부측 --> <div class="text-center bg-pink-50 rounded-lg p-4" data-astro-cid-j7pv25f6> <h4 class="font-semibold mb-3 text-pink-800" data-astro-cid-j7pv25f6>신부측</h4> <div class="space-y-2 text-sm" data-astro-cid-j7pv25f6> <div data-astro-cid-j7pv25f6> <p class="font-medium" data-astro-cid-j7pv25f6>이영희</p> <button class="text-pink-600 underline" data-astro-cid-j7pv25f6>010-5678-9012</button> </div> <div data-astro-cid-j7pv25f6> <p class="font-medium" data-astro-cid-j7pv25f6>아버지 이○○</p> <button class="text-pink-600 underline" data-astro-cid-j7pv25f6>010-5555-6666</button> </div> <div data-astro-cid-j7pv25f6> <p class="font-medium" data-astro-cid-j7pv25f6>어머니 최○○</p> <button class="text-pink-600 underline" data-astro-cid-j7pv25f6>010-7777-8888</button> </div> </div> </div> </div> </section> <!-- Phase 2: 거의 필수 요소 --> <!-- 7. 사진 갤러리 --> <section class="px-6 py-8" data-astro-cid-j7pv25f6> <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>갤러리</h3> <div class="grid grid-cols-2 gap-3" data-astro-cid-j7pv25f6> <div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300" data-astro-cid-j7pv25f6> <span class="text-gray-500 text-sm" data-astro-cid-j7pv25f6>[사진1]</span> </div> <div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300" data-astro-cid-j7pv25f6> <span class="text-gray-500 text-sm" data-astro-cid-j7pv25f6>[사진2]</span> </div> <div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300" data-astro-cid-j7pv25f6> <span class="text-gray-500 text-sm" data-astro-cid-j7pv25f6>[사진3]</span> </div> <div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300" data-astro-cid-j7pv25f6> <span class="text-gray-500 text-sm" data-astro-cid-j7pv25f6>[사진4]</span> </div> </div> <div class="text-center mt-4" data-astro-cid-j7pv25f6> <button class="text-rose-600 underline text-sm" data-astro-cid-j7pv25f6>더 많은 사진 보기</button> </div> </section> <!-- 8. 계좌 정보 --> <section class="px-6 py-8" data-astro-cid-j7pv25f6> <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>마음 전하실 곳</h3> <div class="space-y-4" data-astro-cid-j7pv25f6> <!-- 신랑측 계좌 --> <div class="bg-blue-50 rounded-lg p-4" data-astro-cid-j7pv25f6> <h4 class="font-semibold mb-3 text-blue-800 text-center" data-astro-cid-j7pv25f6>신랑측</h4> <div class="space-y-2" data-astro-cid-j7pv25f6> <div class="flex justify-between items-center bg-white rounded p-3" data-astro-cid-j7pv25f6> <div data-astro-cid-j7pv25f6> <p class="font-medium" data-astro-cid-j7pv25f6>국민은행</p> <p class="text-sm text-gray-600" data-astro-cid-j7pv25f6>123-456-789012</p> <p class="text-sm" data-astro-cid-j7pv25f6>예금주: 김철수</p> </div> <button class="text-blue-600 text-sm underline" data-astro-cid-j7pv25f6>복사</button> </div> </div> </div> <!-- 신부측 계좌 --> <div class="bg-pink-50 rounded-lg p-4" data-astro-cid-j7pv25f6> <h4 class="font-semibold mb-3 text-pink-800 text-center" data-astro-cid-j7pv25f6>신부측</h4> <div class="space-y-2" data-astro-cid-j7pv25f6> <div class="flex justify-between items-center bg-white rounded p-3" data-astro-cid-j7pv25f6> <div data-astro-cid-j7pv25f6> <p class="font-medium" data-astro-cid-j7pv25f6>신한은행</p> <p class="text-sm text-gray-600" data-astro-cid-j7pv25f6>987-654-321098</p> <p class="text-sm" data-astro-cid-j7pv25f6>예금주: 이영희</p> </div> <button class="text-pink-600 text-sm underline" data-astro-cid-j7pv25f6>복사</button> </div> </div> </div> </div> </section> <!-- 9. 상세 인사말 --> <section class="px-6 py-8" data-astro-cid-j7pv25f6> <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>진심을 담아</h3> <div class="bg-gradient-to-b from-rose-50 to-white rounded-lg p-6" data-astro-cid-j7pv25f6> <p class="text-gray-700 leading-relaxed text-center" data-astro-cid-j7pv25f6>
[상세 인사말]<br data-astro-cid-j7pv25f6><br data-astro-cid-j7pv25f6>
안녕하세요, 저희는 3년 전 대학교 동아리에서 만나<br data-astro-cid-j7pv25f6>
서로의 소중함을 알게 되었습니다.<br data-astro-cid-j7pv25f6><br data-astro-cid-j7pv25f6>
이제 평생을 함께하겠다는 약속을 하려 합니다.<br data-astro-cid-j7pv25f6>
바쁘신 중에도 저희의 소중한 순간을<br data-astro-cid-j7pv25f6>
함께해 주시는 모든 분들께 감사드립니다.<br data-astro-cid-j7pv25f6><br data-astro-cid-j7pv25f6>
앞으로도 변함없는 사랑과 격려<br data-astro-cid-j7pv25f6>
부탁드립니다.
</p> </div> </section> <!-- Phase 3: 자주 포함 요소 --> <!-- 10. 달력/카운트다운 --> <section class="px-6 py-8" data-astro-cid-j7pv25f6> <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>결혼식까지</h3> <div class="text-center bg-gradient-to-b from-rose-100 to-rose-50 rounded-lg p-6" data-astro-cid-j7pv25f6> <div class="text-3xl font-bold text-rose-800 mb-2" data-astro-cid-j7pv25f6>
[D-30]
</div> <p class="text-gray-600" data-astro-cid-j7pv25f6>2024년 10월 25일까지</p> <!-- 간단한 달력 표시 --> <div class="mt-6 bg-white rounded-lg p-4" data-astro-cid-j7pv25f6> <p class="text-sm text-gray-500 mb-2" data-astro-cid-j7pv25f6>2024년 10월</p> <div class="w-full h-24 bg-gray-100 rounded flex items-center justify-center" data-astro-cid-j7pv25f6> <span class="text-gray-500" data-astro-cid-j7pv25f6>[달력 위젯]</span> </div> </div> </div> </section> <!-- 11. 교통편 안내 --> <section class="px-6 py-8" data-astro-cid-j7pv25f6> <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>교통편 안내</h3> <div class="space-y-4" data-astro-cid-j7pv25f6> <!-- 지하철 --> <div class="bg-blue-50 rounded-lg p-4" data-astro-cid-j7pv25f6> <h4 class="font-semibold mb-2 text-blue-800 flex items-center" data-astro-cid-j7pv25f6>
🚇 지하철
</h4> <p class="text-sm text-gray-700" data-astro-cid-j7pv25f6>
2호선 강남역 3번 출구 도보 5분<br data-astro-cid-j7pv25f6>
9호선 신논현역 1번 출구 도보 3분
</p> </div> <!-- 버스 --> <div class="bg-green-50 rounded-lg p-4" data-astro-cid-j7pv25f6> <h4 class="font-semibold mb-2 text-green-800 flex items-center" data-astro-cid-j7pv25f6>
🚌 버스
</h4> <p class="text-sm text-gray-700" data-astro-cid-j7pv25f6>
강남 02, 421, 463번<br data-astro-cid-j7pv25f6>
'강남역' 하차 후 도보 5분
</p> </div> <!-- 주차 --> <div class="bg-purple-50 rounded-lg p-4" data-astro-cid-j7pv25f6> <h4 class="font-semibold mb-2 text-purple-800 flex items-center" data-astro-cid-j7pv25f6>
🚗 주차
</h4> <p class="text-sm text-gray-700" data-astro-cid-j7pv25f6>
지하 1층~3층 (3시간 무료)<br data-astro-cid-j7pv25f6>
발렛파킹 가능 (1만원)
</p> </div> </div> </section> <!-- 12. 배경음악 --> <section class="px-6 py-8" data-astro-cid-j7pv25f6> <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>함께 들어요</h3> <div class="bg-gradient-to-r from-rose-100 to-pink-100 rounded-lg p-6 text-center" data-astro-cid-j7pv25f6> <div class="w-full h-16 bg-white rounded-lg flex items-center justify-center mb-4" data-astro-cid-j7pv25f6> <span class="text-gray-500" data-astro-cid-j7pv25f6>[음악 플레이어]</span> </div> <p class="text-sm text-gray-700 mb-2" data-astro-cid-j7pv25f6>우리의 특별한 노래</p> <p class="text-xs text-gray-500" data-astro-cid-j7pv25f6>"All of Me" - John Legend</p> <div class="flex justify-center gap-4 mt-4" data-astro-cid-j7pv25f6> <button class="bg-white rounded-full w-12 h-12 flex items-center justify-center shadow" data-astro-cid-j7pv25f6>
▶️
</button> <button class="bg-white rounded-full w-12 h-12 flex items-center justify-center shadow" data-astro-cid-j7pv25f6>
🔇
</button> </div> </div> </section> <!-- Phase 4: 선택적 요소 --> <!-- 13. 연애 스토리 --> <section class="px-6 py-8" data-astro-cid-j7pv25f6> <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>우리의 이야기</h3> <div class="space-y-6" data-astro-cid-j7pv25f6> <!-- 타임라인 아이템 --> <div class="flex gap-4" data-astro-cid-j7pv25f6> <div class="w-12 h-12 bg-rose-200 rounded-full flex items-center justify-center flex-shrink-0" data-astro-cid-j7pv25f6>
💕
</div> <div data-astro-cid-j7pv25f6> <h4 class="font-semibold text-rose-800" data-astro-cid-j7pv25f6>2019.03 첫 만남</h4> <p class="text-sm text-gray-600 mt-1" data-astro-cid-j7pv25f6>대학교 동아리에서 처음 만났어요</p> </div> </div> <div class="flex gap-4" data-astro-cid-j7pv25f6> <div class="w-12 h-12 bg-pink-200 rounded-full flex items-center justify-center flex-shrink-0" data-astro-cid-j7pv25f6>
💖
</div> <div data-astro-cid-j7pv25f6> <h4 class="font-semibold text-pink-800" data-astro-cid-j7pv25f6>2020.05 첫 고백</h4> <p class="text-sm text-gray-600 mt-1" data-astro-cid-j7pv25f6>코로나로 힘든 시기, 서로가 힘이 되어주었어요</p> </div> </div> <div class="flex gap-4" data-astro-cid-j7pv25f6> <div class="w-12 h-12 bg-red-200 rounded-full flex items-center justify-center flex-shrink-0" data-astro-cid-j7pv25f6>
💍
</div> <div data-astro-cid-j7pv25f6> <h4 class="font-semibold text-red-800" data-astro-cid-j7pv25f6>2022.12 프로포즈</h4> <p class="text-sm text-gray-600 mt-1" data-astro-cid-j7pv25f6>눈 내리는 겨울날, 특별한 순간이었어요</p> </div> </div> <div class="flex gap-4" data-astro-cid-j7pv25f6> <div class="w-12 h-12 bg-rose-300 rounded-full flex items-center justify-center flex-shrink-0" data-astro-cid-j7pv25f6>
💒
</div> <div data-astro-cid-j7pv25f6> <h4 class="font-semibold text-rose-800" data-astro-cid-j7pv25f6>2024.10 결혼</h4> <p class="text-sm text-gray-600 mt-1" data-astro-cid-j7pv25f6>드디어 평생을 함께하게 되었습니다</p> </div> </div> </div> </section> <!-- 푸터 --> <footer class="px-6 py-8 text-center bg-rose-100" data-astro-cid-j7pv25f6> <p class="text-sm text-gray-600 mb-2" data-astro-cid-j7pv25f6>
김철수 ♥ 이영희
</p> <p class="text-xs text-gray-500" data-astro-cid-j7pv25f6>
2024년 10월 25일 토요일 오후 2시<br data-astro-cid-j7pv25f6>
서울웨딩홀 3층 그레이스홀
</p> </footer> </main>  <script>
			class CurtainEffect {
				constructor() {
					this.viewportWidth = window.innerWidth;
					this.viewportHeight = window.innerHeight;
					this.centerX = this.viewportWidth / 2;
					this.centerY = this.viewportHeight * 2 / 3; // 아래서 1/3 지점 (위에서 2/3 지점)
					
					// 각 페이즈별 독립적 시간 설정
					this.initialWaitDuration = 1000; // 초기 1초 대기
					this.phase0Duration = 500; // 초기 회색 가로줄 생성 (500ms)
					this.phase0WaitDuration = 1000; // 휴면 시간 (1000ms)
					this.phase1Duration = 400; // 꼭지점 이동 (400ms)
					this.phase2Duration = 300; // 대기 시간 (300ms)
					this.phase3Duration = 2000; // 커튼 이동 + 주름 (2초)
					this.totalDuration = this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration + this.phase1Duration + this.phase2Duration + this.phase3Duration;
					
					this.startTime = null;
					this.wrinkleLines = [];
					
					this.init();
				}
				
				init() {
					this.setupCurtains();
					this.setupWrinkles();
					this.setupInitialGrayLines();
					this.startAnimation();
				}
				
				setupCurtains() {
					const topLeft = document.getElementById('curtain-top-left');
					const topRight = document.getElementById('curtain-top-right');
					const bottomLeft = document.getElementById('curtain-bottom-left');
					const bottomRight = document.getElementById('curtain-bottom-right');
					
					// 초기 위치 설정 - 화면 전체를 덮음
					topLeft.style.left = '0px';
					topLeft.style.top = '0px';
					topLeft.style.width = this.centerX + 'px';
					topLeft.style.height = this.centerY + 'px';
					
					topRight.style.left = this.centerX + 'px';
					topRight.style.top = '0px';
					topRight.style.width = (this.viewportWidth - this.centerX) + 'px';
					topRight.style.height = this.centerY + 'px';
					
					bottomLeft.style.left = '0px';
					bottomLeft.style.top = this.centerY + 'px';
					bottomLeft.style.width = this.centerX + 'px';
					bottomLeft.style.height = (this.viewportHeight - this.centerY) + 'px';
					
					bottomRight.style.left = this.centerX + 'px';
					bottomRight.style.top = this.centerY + 'px';
					bottomRight.style.width = (this.viewportWidth - this.centerX) + 'px';
					bottomRight.style.height = (this.viewportHeight - this.centerY) + 'px';
				}
				
				setupWrinkles() {
					const container = document.getElementById('wrinkles-container');
					
					if (!container) {
						return;
					}
					
					// 각 사각형마다 5개씩 세로선 생성 (총 20개)
					const sections = [
						{ id: 'top-left', x: 0, y: 0, w: this.centerX, h: this.centerY },
						{ id: 'top-right', x: this.centerX, y: 0, w: this.viewportWidth - this.centerX, h: this.centerY },
						{ id: 'bottom-left', x: 0, y: this.centerY, w: this.centerX, h: this.viewportHeight - this.centerY },
						{ id: 'bottom-right', x: this.centerX, y: this.centerY, w: this.viewportWidth - this.centerX, h: this.viewportHeight - this.centerY }
					];
					
					let totalCreated = 0;
					sections.forEach(section => {
						for (let i = 1; i <= 5; i++) {
							const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
							line.classList.add('wrinkle-line');
							line.dataset.section = section.id;
							line.dataset.index = i;
							
							// 각 섹션을 6등분하여 5개 선 배치 (양끝 제외)
							const isLeftSection = section.id.includes('left');
							const sectionWidth = isLeftSection ? this.centerX : (this.viewportWidth - this.centerX);
							const spacing = sectionWidth / 6; // 6등분
							
							const x = isLeftSection ? 
								(spacing * i) : // 왼쪽 섹션: spacing, 2*spacing, 3*spacing, 4*spacing, 5*spacing
								(this.centerX + (spacing * i)); // 오른쪽 섹션: centerX + spacing, centerX + 2*spacing, ...
							line.setAttribute('x1', x);
							line.setAttribute('y1', section.y);
							line.setAttribute('x2', x);
							line.setAttribute('y2', section.y + section.h);
							line.setAttribute('stroke', '#d1d5db');
							line.setAttribute('stroke-width', '3');
							line.setAttribute('opacity', '0');
							
							// 초기 상태는 보이지 않음
							
							container.appendChild(line);
							this.wrinkleLines.push({
								element: line,
								section: section.id,
								index: i,
								originalX: x,
								originalY: section.y,
								originalHeight: section.h,
								activated: false,
								screenPointMoving: false, // 화면 맞닿는 점 이동 여부
								activationCurtainMove: null, // 주름이 활성화될 때의 커튼 이동량 저장
								rotationEndCoords: null, // 회전이 끝날 때의 좌표 저장 {x1, y1, x2, y2}
								linearStartPhaseProgress: null, // 선형이동 시작 시점의 phaseProgress
								activationTime: null, // 활성화 시점 기록
								fadeInDelay: 0, // 페이드인 지연 시간
								fadeInDuration: 150 // 페이드인 지속 시간
							});
							totalCreated++;
						}
					});
					
				}
				
				setupInitialGrayLines() {
					const leftLine = document.getElementById('initial-gray-line-left');
					const rightLine = document.getElementById('initial-gray-line-right');
					
					// 초기 위치 설정: 화면을 관통하는 띠 (커튼 고정용)
					// 왼쪽 반: 화면 왼쪽 끝부터 중심까지
					leftLine.style.left = '0px';
					leftLine.style.top = this.centerY + 'px';
					leftLine.style.width = this.centerX + 'px';
					
					// 오른쪽 반: 중심부터 화면 오른쪽 끝까지
					rightLine.style.left = this.centerX + 'px';
					rightLine.style.top = this.centerY + 'px';
					rightLine.style.width = (this.viewportWidth - this.centerX) + 'px';
				}
				
				startAnimation() {
					this.startTime = performance.now();
					this.animate();
				}
				
				animate() {
					const currentTime = performance.now();
					const elapsed = currentTime - this.startTime;
					
					// 현재 페이즈와 해당 페이즈 내 진행률 계산
					let currentPhase, phaseProgress;
					
					if (elapsed <= this.initialWaitDuration) {
						// 초기 1초 대기
						currentPhase = -1;
						phaseProgress = elapsed / this.initialWaitDuration;
					} else if (elapsed <= this.initialWaitDuration + this.phase0Duration) {
						// 페이즈 0: 초기 회색 가로줄 생성
						currentPhase = 0;
						phaseProgress = (elapsed - this.initialWaitDuration) / this.phase0Duration;
					} else if (elapsed <= this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration) {
						// 페이즈 0.5: 휴면 (대기)
						currentPhase = 0.5;
						phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration) / this.phase0WaitDuration;
					} else if (elapsed <= this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration + this.phase1Duration) {
						// 페이즈 1: 꼭지점 이동
						currentPhase = 1;
						phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration - this.phase0WaitDuration) / this.phase1Duration;
					} else if (elapsed <= this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration + this.phase1Duration + this.phase2Duration) {
						// 페이즈 2: 대기
						currentPhase = 2;
						phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration - this.phase0WaitDuration - this.phase1Duration) / this.phase2Duration;
					} else if (elapsed <= this.totalDuration) {
						// 페이즈 3: 커튼 이동 + 주름
						currentPhase = 3;
						phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration - this.phase0WaitDuration - this.phase1Duration - this.phase2Duration) / this.phase3Duration;
					} else {
						// 애니메이션 완료
						currentPhase = 4;
						phaseProgress = 1;
					}
					
					this.updateInitialOverlay(currentPhase, phaseProgress);
					this.updateInitialGrayLines(currentPhase, phaseProgress);
					this.updateCurtains(currentPhase, phaseProgress);
					this.updateWrinkles(currentPhase, phaseProgress);
					
					if (currentPhase < 4) {
						requestAnimationFrame(() => this.animate());
					} else {
						this.cleanup();
					}
				}
				
				updateInitialOverlay(currentPhase, phaseProgress) {
					const initialOverlay = document.getElementById('initial-overlay');
					
					// 오버레이가 존재할 때만 처리
					if (!initialOverlay) return;
					
					if (currentPhase === -1) {
						// 초기 1초 대기: 투명도 0에서 1로 서서히 변화
						const opacity = this.easeOutCubic(phaseProgress);
						initialOverlay.style.opacity = opacity;
						
					} else if (currentPhase >= 0) {
						// 페이즈 0 이후: 완전히 보임 상태 유지
						initialOverlay.style.opacity = '1';
					}
				}
				
				updateInitialGrayLines(currentPhase, phaseProgress) {
					const leftLine = document.getElementById('initial-gray-line-left');
					const rightLine = document.getElementById('initial-gray-line-right');
					
					if (currentPhase === -1) {
						// 초기 1초 대기: 아무것도 표시하지 않음
						leftLine.style.opacity = '0';
						rightLine.style.opacity = '0';
						
					} else if (currentPhase === 0) {
						// 페이즈 0: 회색 가로줄 페이드인 (200ms)
						const opacity = this.easeOutCubic(phaseProgress);
						leftLine.style.opacity = opacity;
						rightLine.style.opacity = opacity;
						
					} else if (currentPhase === 0.5) {
						// 페이즈 0.5: 휴면 상태 (300ms) - 완전 보임
						leftLine.style.opacity = '1';
						rightLine.style.opacity = '1';
						
					} else if (currentPhase === 1) {
						// 페이즈 1: 꼭지점 이동과 함께 띠가 중앙에서 벌어짐 (찢어지는 효과)
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const cornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
						
						// 왼쪽 띠: 중심에서 왼쪽으로 벌어짐
						leftLine.style.left = '0px';
						leftLine.style.width = (this.centerX - cornerMove) + 'px';
						
						// 오른쪽 띠: 중심에서 오른쪽으로 벌어짐
						rightLine.style.left = (this.centerX + cornerMove) + 'px';
						rightLine.style.width = (this.viewportWidth - this.centerX - cornerMove) + 'px';
						
					} else if (currentPhase === 2) {
						// 페이즈 2: 대기 - 찢어진 상태 유지
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						
						leftLine.style.left = '0px';
						leftLine.style.width = (this.centerX - maxCornerMove) + 'px';
						leftLine.style.opacity = '1';
						
						rightLine.style.left = (this.centerX + maxCornerMove) + 'px';
						rightLine.style.width = (this.viewportWidth - this.centerX - maxCornerMove) + 'px';
						rightLine.style.opacity = '1';
						
					} else if (currentPhase === 3) {
						// 페이즈 3: 커튼과 함께 띠도 좌우로 이동 (중앙 꼭지점과 같은 속도)
						const maxMove = this.viewportWidth * 1.5;
						const fastMove = maxMove * this.easeInCubic(phaseProgress * 1.5); // 중앙 꼭지점과 같은 속도
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						
						// 왼쪽 띠: 왼쪽으로 이동
						leftLine.style.transform = `translateX(${-fastMove}px)`;
						leftLine.style.left = '0px';
						leftLine.style.width = (this.centerX - maxCornerMove) + 'px';
						leftLine.style.opacity = '1';
						
						// 오른쪽 띠: 오른쪽으로 이동
						rightLine.style.transform = `translateX(${fastMove}px)`;
						rightLine.style.left = (this.centerX + maxCornerMove) + 'px';
						rightLine.style.width = (this.viewportWidth - this.centerX - maxCornerMove) + 'px';
						rightLine.style.opacity = '1';
					}
				}
				
				updateCurtains(currentPhase, phaseProgress) {
					const topLeft = document.getElementById('curtain-top-left');
					const topRight = document.getElementById('curtain-top-right');
					const bottomLeft = document.getElementById('curtain-bottom-left');
					const bottomRight = document.getElementById('curtain-bottom-right');
					const initialOverlay = document.getElementById('initial-overlay');
					
					if (currentPhase === 1) {
						// 커튼(네모4개) 생성 시점에서 흰색 덮개 삭제
						if (initialOverlay) {
							initialOverlay.remove();
						}
						// 페이즈 1: 꼭지점만 이동 (400ms)
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const cornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
						
						// 왼쪽 위: 오른쪽 아래 꼭지점이 왼쪽으로
						topLeft.style.clipPath = `polygon(0% 0%, 100% 0%, ${100 - (cornerMove/this.centerX)*100}% 100%, 0% 100%)`;
						
						// 오른쪽 위: 왼쪽 아래 꼭지점이 오른쪽으로
						topRight.style.clipPath = `polygon(${(cornerMove/(this.viewportWidth-this.centerX))*100}% 100%, 100% 100%, 100% 0%, 0% 0%)`;
						
						// 왼쪽 아래: 오른쪽 위 꼭지점이 왼쪽으로
						bottomLeft.style.clipPath = `polygon(0% 0%, ${100 - (cornerMove/this.centerX)*100}% 0%, 100% 100%, 0% 100%)`;
						
						// 오른쪽 아래: 왼쪽 위 꼭지점이 오른쪽으로
						bottomRight.style.clipPath = `polygon(${(cornerMove/(this.viewportWidth-this.centerX))*100}% 0%, 100% 0%, 100% 100%, 0% 100%)`;
						
					} else if (currentPhase === 2) {
						// 페이즈 2: 대기 (300ms) - clipPath 상태 유지
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						
						topLeft.style.clipPath = `polygon(0% 0%, 100% 0%, ${100 - (maxCornerMove/this.centerX)*100}% 100%, 0% 100%)`;
						topRight.style.clipPath = `polygon(${(maxCornerMove/(this.viewportWidth-this.centerX))*100}% 100%, 100% 100%, 100% 0%, 0% 0%)`;
						bottomLeft.style.clipPath = `polygon(0% 0%, ${100 - (maxCornerMove/this.centerX)*100}% 0%, 100% 100%, 0% 100%)`;
						bottomRight.style.clipPath = `polygon(${(maxCornerMove/(this.viewportWidth-this.centerX))*100}% 0%, 100% 0%, 100% 100%, 0% 100%)`;
						
					} else if (currentPhase === 3) {
						// 페이즈 3: 전체 이동 (1600ms) - 중앙 꼭지점만 더 빨리
						const maxMove = this.viewportWidth * 1.5;
						const normalMove = maxMove * this.easeInCubic(phaseProgress); // 모서리 점 속도
						const fastMove = maxMove * this.easeInCubic(phaseProgress * 1.5); // 중앙 꼭지점 속도
						
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						
						// 중앙 꼭지점(clipPath 안의 꼭지점)은 빠르게, 모서리는 천천히
						const fastCornerX = this.centerX - maxCornerMove - fastMove; // 왼쪽 중앙 꼭지점
						const fastCornerXRight = this.centerX + maxCornerMove + fastMove; // 오른쪽 중앙 꼭지점
						
						// 각 사각형은 천천히 이동, clipPath만 빠르게 변경
						topLeft.style.transform = `translateX(${-normalMove}px)`;
						topLeft.style.clipPath = `polygon(0% 0%, 100% 0%, ${((fastCornerX + normalMove) / this.centerX) * 100}% 100%, 0% 100%)`;
						
						topRight.style.transform = `translateX(${normalMove}px)`;
						topRight.style.clipPath = `polygon(${((fastCornerXRight - normalMove - this.centerX) / this.centerX) * 100}% 100%, 100% 100%, 100% 0%, 0% 0%)`;
						
						bottomLeft.style.transform = `translateX(${-normalMove}px)`;
						bottomLeft.style.clipPath = `polygon(0% 0%, ${((fastCornerX + normalMove) / this.centerX) * 100}% 0%, 100% 100%, 0% 100%)`;
						
						bottomRight.style.transform = `translateX(${normalMove}px)`;
						bottomRight.style.clipPath = `polygon(${((fastCornerXRight - normalMove - this.centerX) / this.centerX) * 100}% 0%, 100% 0%, 100% 100%, 0% 100%)`;
					}
				}
				
				updateWrinkles(currentPhase, phaseProgress) {
					let leftCornerX = null;
					let rightCornerX = null;
					
					if (currentPhase === 1) {
						// 페이즈 1: clipPath 기반 꼭지점 이동
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const currentCornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
						
						leftCornerX = this.centerX - currentCornerMove;  
						rightCornerX = this.centerX + currentCornerMove; 
						
					} else if (currentPhase >= 3) {
						// 페이즈 3: transform 기반 전체 이동
						// 페이즈 1 완료 시의 최종 꼭지점 위치
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						
						// 페이즈 3에서의 transform 이동량 - 주름 커튼점은 빠르게
						const maxMove = this.viewportWidth * 1.5;
						const fastMove = maxMove * this.easeInCubic(phaseProgress * 1.5); // 커튼과 같은 속도
						
						// 중앙 꼭지점과 동일한 계산식 사용
						leftCornerX = this.centerX - maxCornerMove - fastMove;
						rightCornerX = this.centerX + maxCornerMove + fastMove;
					}
					
					if (leftCornerX !== null && rightCornerX !== null) {
						this.wrinkleLines.forEach((wrinkle, index) => {
							if (!wrinkle.activated) {
								const wrinkleX = wrinkle.originalX;
								const isLeftSection = wrinkle.section.includes('left');
								
								// 주름 간격(x) 계산
								const sectionWidth = isLeftSection ? this.centerX : (this.viewportWidth - this.centerX);
								const spacing = sectionWidth / 6; // x = spacing
								const earlyOffset = spacing / 5; // x/5
								
								// 꼭지점이 주름 위치에 (x/5) 전에 도달했을 때 활성화
								const shouldActivate = isLeftSection ? 
									(leftCornerX <= (wrinkleX + earlyOffset)) :   // 왼쪽: 커튼이 주름보다 (x/5) 오른쪽에 있을 때
									(rightCornerX >= (wrinkleX - earlyOffset));   // 오른쪽: 커튼이 주름보다 (x/5) 왼쪽에 있을 때
								
								if (shouldActivate) {
									wrinkle.element.classList.add('wrinkle-visible');
									wrinkle.activated = true;
									wrinkle.activationTime = performance.now(); // 활성화 시점 기록
									
									// 중앙에서 바깥쪽 순서로 지연시간 계산
									const n = isLeftSection ? 
										(5 - wrinkle.index) :  // 왼쪽: left-5가 n=0, left-1이 n=4
										(wrinkle.index - 1);   // 오른쪽: right-1이 n=0, right-5가 n=4
									wrinkle.fadeInDelay = 0; // 지연시간 없음
									wrinkle.fadeInDuration = 150; // 150ms에 걸쳐 서서히 나타남
								}
							}
							
							// 활성화된 주름들 처리
							if (wrinkle.activated) {
								// 투명도 페이드인 처리
								const currentTime = performance.now();
								const elapsed = currentTime - wrinkle.activationTime;
								
								if (elapsed >= wrinkle.fadeInDelay) {
									// 페이드인 시작 후 경과 시간
									const fadeElapsed = elapsed - wrinkle.fadeInDelay;
									
									if (fadeElapsed < wrinkle.fadeInDuration) {
										// 페이드인 중: 0에서 0.8로 서서히 증가 (더 진하게)
										const progress = fadeElapsed / wrinkle.fadeInDuration;
										const opacity = 0.8 * this.easeOutCubic(progress);
										wrinkle.element.setAttribute('opacity', Math.max(0, opacity).toString());
									} else {
										// 페이드인 완료: 최대 투명도 유지
										wrinkle.element.setAttribute('opacity', '0.8');
									}
								} else {
									// 지연시간 중: 완전히 투명하게 유지
									wrinkle.element.setAttribute('opacity', '0');
								}
								// 화면 맞닿는 점 이동 조건 확인
								if (!wrinkle.screenPointMoving) {
									const isLeftSection = wrinkle.section.includes('left');
									const sectionWidth = isLeftSection ? this.centerX : (this.viewportWidth - this.centerX);
									const spacing = sectionWidth / 6; // x = 주름 간격
									
									// 중심에 가까운 순서대로 n 계산 (0부터 시작)
									const n = isLeftSection ? 
										(5 - wrinkle.index) :  // 왼쪽: left-5가 n=0, left-1이 n=4
										(wrinkle.index - 1);   // 오른쪽: right-1이 n=0, right-5가 n=4
									
									// 커튼 이동점 (leftCornerX 또는 rightCornerX)
									const curtainMovingX = isLeftSection ? leftCornerX : rightCornerX;
									const curtainTotalMove = Math.abs(curtainMovingX - this.centerX);
									
									// 주름이 활성화될 때의 커튼 이동량 저장
									if (wrinkle.activationCurtainMove === null) {
										wrinkle.activationCurtainMove = curtainTotalMove;
									}
									
									// 회전 정지 조건: 활성화 후 x*(6-n)/6만큼 추가 이동
									const additionalMoveNeeded = spacing * (6 - n) / 6; // x*(6-n)/6
									const rotationStopMove = wrinkle.activationCurtainMove + additionalMoveNeeded;
									
									// 조건 달성 시 화면 점 이동 시작
									if (curtainTotalMove >= rotationStopMove) {
										
										// 회전이 끝나는 시점의 좌표를 화면점/커튼점으로 명확히 구분해서 저장
										const isTopSection = wrinkle.section.includes('top');
										wrinkle.rotationEndCoords = {
											screenX: isTopSection ? parseFloat(wrinkle.element.getAttribute('x1')) : parseFloat(wrinkle.element.getAttribute('x2')),
											screenY: isTopSection ? parseFloat(wrinkle.element.getAttribute('y1')) : parseFloat(wrinkle.element.getAttribute('y2')),
											curtainX: isTopSection ? parseFloat(wrinkle.element.getAttribute('x2')) : parseFloat(wrinkle.element.getAttribute('x1')),
											curtainY: isTopSection ? parseFloat(wrinkle.element.getAttribute('y2')) : parseFloat(wrinkle.element.getAttribute('y1'))
										};
										
										// 이동 시작 시점의 커튼 위치와 phaseProgress 저장
										const isLeftSection = wrinkle.section.includes('left');
										wrinkle.linearStartCurtainX = isLeftSection ? leftCornerX : rightCornerX;
										wrinkle.linearStartPhaseProgress = phaseProgress; // 선형이동 시작 시점의 phaseProgress
										wrinkle.screenPointMoving = true;
									}
								}
								
								// 주름 업데이트 (회전 또는 이동)
								if (wrinkle.screenPointMoving) {
									// 선형 이동 모드
									this.updateWrinkleLinearMovement(wrinkle, currentPhase, phaseProgress, leftCornerX, rightCornerX);
								} else {
									// 회전 모드
									this.updateWrinkleTilt(wrinkle, currentPhase, phaseProgress, leftCornerX, rightCornerX);
								}
							}
						});
					}
				}
				
				updateWrinkleTilt(wrinkle, currentPhase, phaseProgress, leftCornerX, rightCornerX) {
					const isLeftSection = wrinkle.section.includes('left');
					const isTopSection = wrinkle.section.includes('top');
					
					// 회전 모드: 화면 맞닿는 점 고정
					const fixedX = wrinkle.originalX;
					const fixedY = isTopSection ? wrinkle.originalY : (wrinkle.originalY + wrinkle.originalHeight); // top이면 위점 고정, bottom이면 아래점 고정
					
					// 커튼점 위치는 매개변수로 받음
					const cornerX = isLeftSection ? leftCornerX : rightCornerX;
					const cornerY = this.centerY;
					
					if (cornerX !== undefined && cornerY !== undefined) {
						// 이동점은 반드시 꼭지점 이동경로(y = this.centerY)에 맞닿아야 함
						const movingX = cornerX;
						const movingY = this.centerY; // 꼭지점 이동경로인 중앙 가로선에 고정
						
						// 고정점에서 이동점까지의 실제 거리 계산 (길이가 늘어남)
						const dx = movingX - fixedX;
						const dy = movingY - fixedY;
						const currentLength = Math.sqrt(dx * dx + dy * dy);
						
						// 원래 섹션 높이 (회전하지 않을 때)
						const originalSectionHeight = isTopSection ? this.centerY : (this.viewportHeight - this.centerY);
						
						// 기본 회전각 c 계산 (1페이즈 완료 시 커튼 기울기)
						const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
						const basicAngle = Math.atan(maxCornerMove / originalSectionHeight);
						
						// 현재 회전각 계산 (꼭지점 이동에 비례)
						const currentCornerMove = Math.abs(cornerX - this.centerX);
						const currentAngle = Math.atan(currentCornerMove / originalSectionHeight);
						
						// 최대 회전각 y는 기본각의 3배로 설정
						const maxAngle = basicAngle * 3;
						const rotationAngle = Math.min(currentAngle, maxAngle);
						
						// 실제 좌표는 이미 계산됨 (이동점이 꼭지점 경로에 맞닿음)
						const newMovingX = movingX;
						const newMovingY = movingY;
						
						// SVG 라인 업데이트
						if (isTopSection) {
							// top 섹션: 위점 고정, 아래점 이동
							wrinkle.element.setAttribute('x1', fixedX);
							wrinkle.element.setAttribute('y1', fixedY);
							wrinkle.element.setAttribute('x2', newMovingX);
							wrinkle.element.setAttribute('y2', newMovingY);
						} else {
							// bottom 섹션: 아래점 고정, 위점 이동
							wrinkle.element.setAttribute('x1', newMovingX);
							wrinkle.element.setAttribute('y1', newMovingY);
							wrinkle.element.setAttribute('x2', fixedX);
							wrinkle.element.setAttribute('y2', fixedY);
						}
					}
				}
				
				updateWrinkleLinearMovement(wrinkle, currentPhase, phaseProgress, leftCornerX, rightCornerX) {
					const isLeftSection = wrinkle.section.includes('left');
					const isTopSection = wrinkle.section.includes('top');
					
					// 회전이 끝났을 때의 좌표는 이미 전환 시점에 저장되었음
					
					// 커튼점 위치는 매개변수로 받음
					const cornerX = isLeftSection ? leftCornerX : rightCornerX;
					const cornerY = this.centerY;
					
					if (cornerX !== undefined && cornerY !== undefined) {
						// 화면 맞닿는 점: 회전 종료 시점 위치에서 상대적 진행률로 이동
						const direction = isLeftSection ? -1 : 1;
						const maxMove = this.viewportWidth * 1.5;
						
						// 전체 진행률 기반 이동량에서 시작점 이동량을 빼서 실제 이동량 계산
						const totalScreenMove = maxMove * this.easeInCubic(phaseProgress);  // 전체 이동량
						const startingScreenMove = maxMove * this.easeInCubic(wrinkle.linearStartPhaseProgress); // 시작 시점 이동량
						const screenMove = totalScreenMove - startingScreenMove; // 실제 이동량 (시작점에서 0부터 시작)
						
						// 회전 종료 시점의 화면 맞닿는 점에서 상대적 이동
						const screenMovingX = wrinkle.rotationEndCoords.screenX + (direction * screenMove);
						const screenMovingY = wrinkle.rotationEndCoords.screenY;
						
						
						// SVG 라인 업데이트: 회전된 상태를 유지하면서 이동
						if (isTopSection) {
							// top 섹션: x1=화면점, x2=커튼점
							wrinkle.element.setAttribute('x1', screenMovingX);
							wrinkle.element.setAttribute('y1', screenMovingY);
							wrinkle.element.setAttribute('x2', cornerX);
							wrinkle.element.setAttribute('y2', cornerY);
						} else {
							// bottom 섹션: x1=커튼점, x2=화면점
							wrinkle.element.setAttribute('x1', cornerX);
							wrinkle.element.setAttribute('y1', cornerY);
							wrinkle.element.setAttribute('x2', screenMovingX);
							wrinkle.element.setAttribute('y2', screenMovingY);
						}
						
					}
				}
				
				cleanup() {
					// 애니메이션 완료 후 검은 화면 먼저 페이드아웃
					const blackScreen = document.getElementById('black-screen');
					const overlay = document.getElementById('curtain-overlay');
					
					if (blackScreen) {
						// 검은 화면을 500ms에 걸쳐 페이드아웃
						blackScreen.style.transition = 'opacity 500ms ease-out';
						blackScreen.style.opacity = '0';
						
						// 검은 화면 페이드아웃 완료 후 전체 오버레이 제거
						setTimeout(() => {
							overlay.style.opacity = '0';
							setTimeout(() => {
								overlay.remove();
							}, 300);
						}, 500); // 검은 화면 페이드아웃 시간과 동일
					} else {
						// 검은 화면이 없을 경우 기존 방식 유지
						overlay.style.opacity = '0';
						setTimeout(() => {
							overlay.remove();
						}, 300);
					}
				}
				
				// 이징 함수들
				easeOutCubic(t) {
					return 1 - Math.pow(1 - t, 3);
				}
				
				easeInCubic(t) {
					return t * t * t;
				}
				
				easeOutQuad(t) {
					return 1 - (1 - t) * (1 - t);
				}
			}
			
			// 페이지 로드 시 커튼 효과 시작
			window.addEventListener('load', () => {
				window.curtainEffectInstance = new CurtainEffect();
			});
		</script> </body> </html>