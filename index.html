<!DOCTYPE html>
<html lang="ko" data-astro-cid-j7pv25f6>
 <head>
  <meta charset="utf-8">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>김철수 ♥ 이영희 결혼식</title>
  <meta name="description" content="김철수와 이영희의 결혼식에 초대합니다">
  <link rel="stylesheet" href="/_astro/index.DV-eWruZ.css">
  <!-- 강제 캐시 무효화: 2025-01-14-13:13 -->
 </head>
 <body class="text-gray-800 font-sans bg-rose-50" data-astro-cid-j7pv25f6>
  
  <!-- 커튼 효과 요소들 -->
  <div id="curtain-overlay" class="fixed inset-0 z-50 pointer-events-none" data-curtain="true" style="display: block;" data-astro-cid-j7pv25f6>
   
   <!-- 검은 화면 (본 화면을 가리는 용도) -->
   <div id="black-screen" class="absolute bg-black" style="z-index: 49; display: block; position: absolute; inset: 0; background-color: black; opacity: 1;" data-curtain="black-screen" data-astro-cid-j7pv25f6><!-- 검은 화면 --></div>
   
   <!-- 초기 전체 화면 덮개 -->
   <div id="initial-overlay" class="absolute bg-white" style="z-index: 50; display: block; position: absolute; inset: 0; background-color: white; opacity: 0;" data-curtain="initial-overlay" data-astro-cid-j7pv25f6><!-- 초기 화면 덮개 --></div>
   
   <!-- 4개의 하얀 사각형 -->
   <div id="curtain-top-left" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel" data-astro-cid-j7pv25f6><!-- 커튼 패널 --></div>
   <div id="curtain-top-right" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel" data-astro-cid-j7pv25f6><!-- 커튼 패널 --></div>
   <div id="curtain-bottom-left" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel" data-astro-cid-j7pv25f6><!-- 커튼 패널 --></div>
   <div id="curtain-bottom-right" class="absolute bg-white" style="z-index: 51; display: block; position: absolute; background-color: white;" data-curtain="panel" data-astro-cid-j7pv25f6><!-- 커튼 패널 --></div>
   
   <!-- 초기 회색 가로줄 -->
   <div id="initial-gray-line-left" class="absolute bg-gray-400" style="z-index: 53; display: block; height: 2px; opacity: 0;" data-curtain="initial-line" data-astro-cid-j7pv25f6><!-- 초기 가로줄 왼쪽 --></div>
   <div id="initial-gray-line-right" class="absolute bg-gray-400" style="z-index: 53; display: block; height: 2px; opacity: 0;" data-curtain="initial-line" data-astro-cid-j7pv25f6><!-- 초기 가로줄 오른쪽 --></div>
   
   <!-- 20개의 주름 세로선 -->
   <svg id="wrinkles-container" style="z-index: 52; display: block; position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none;" data-curtain="wrinkles" data-astro-cid-j7pv25f6>
    <!-- 주름 선들이 여기에 동적으로 추가됩니다 -->
   </svg>
  </div>
  
  <main class="max-w-md mx-auto bg-white min-h-screen" data-astro-cid-j7pv25f6>
   
   <!-- Phase 1: 필수 요소 -->
   <!-- 1. 신랑신부 정보 + 2. 결혼식 정보 -->
   <section class="text-center py-12 px-6 bg-gradient-to-b from-rose-100 to-white" data-astro-cid-j7pv25f6>
    <div class="mb-8" data-astro-cid-j7pv25f6>
     <h1 class="text-3xl font-bold text-rose-800 mb-2" data-astro-cid-j7pv25f6>
      김철수 ♥ 이영희
     </h1>
     <p class="text-sm text-gray-600 mb-4" data-astro-cid-j7pv25f6>
      김○○ · 박○○ 의 장남 철수<br data-astro-cid-j7pv25f6>
      이○○ · 최○○ 의 장녀 영희
     </p>
    </div>
    <div class="text-center" data-astro-cid-j7pv25f6>
     <h2 class="text-xl font-semibold text-gray-700 mb-2" data-astro-cid-j7pv25f6>
      2024년 10월 25일 토요일
     </h2>
     <p class="text-lg text-rose-700" data-astro-cid-j7pv25f6>
      오후 2시
     </p>
    </div>
   </section>
   
   <!-- 6. 메인 사진 -->
   <section class="px-6 py-8" data-astro-cid-j7pv25f6>
    <div class="w-full h-80 bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300" data-astro-cid-j7pv25f6>
     <span class="text-gray-500 text-lg font-medium" data-astro-cid-j7pv25f6>[메인 웨딩사진]</span>
    </div>
   </section>
   
   <!-- 5. 기본 인사말 -->
   <section class="px-6 py-8 text-center" data-astro-cid-j7pv25f6>
    <div class="bg-rose-50 rounded-lg p-6" data-astro-cid-j7pv25f6>
     <h3 class="text-lg font-semibold mb-4 text-rose-800" data-astro-cid-j7pv25f6>소중한 분들께</h3>
     <p class="text-gray-700 leading-relaxed" data-astro-cid-j7pv25f6>
      [기본 인사말]<br data-astro-cid-j7pv25f6>
      저희 두 사람이 사랑의 결실을 맺게 되었습니다.<br data-astro-cid-j7pv25f6>
      소중한 분들과 함께 새로운 시작을 하고자 합니다.<br data-astro-cid-j7pv25f6>
      바쁘신 중에도 참석하시어 축복해 주시면<br data-astro-cid-j7pv25f6>
      더없는 기쁨이겠습니다.
     </p>
    </div>
   </section>
   
   <!-- 3. 장소 정보 -->
   <section class="px-6 py-8" data-astro-cid-j7pv25f6>
    <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>오시는 길</h3>
    <!-- 지도 영역 -->
    <div class="w-full h-48 bg-gray-200 rounded-lg mb-4 flex items-center justify-center border-2 border-dashed border-gray-300" data-astro-cid-j7pv25f6>
     <span class="text-gray-500 text-lg font-medium" data-astro-cid-j7pv25f6>[카카오맵]</span>
    </div>
    <div class="text-center" data-astro-cid-j7pv25f6>
     <h4 class="text-lg font-semibold mb-2" data-astro-cid-j7pv25f6>서울웨딩홀</h4>
     <p class="text-gray-600 mb-2" data-astro-cid-j7pv25f6>3층 그레이스홀</p>
     <p class="text-sm text-gray-500" data-astro-cid-j7pv25f6>서울시 강남구 테헤란로 123</p>
    </div>
   </section>
   
   <!-- 4. 연락처 -->
   <section class="px-6 py-8" data-astro-cid-j7pv25f6>
    <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>연락처</h3>
    <div class="grid grid-cols-2 gap-4" data-astro-cid-j7pv25f6>
     <!-- 신랑측 -->
     <div class="text-center bg-blue-50 rounded-lg p-4" data-astro-cid-j7pv25f6>
      <h4 class="font-semibold mb-3 text-blue-800" data-astro-cid-j7pv25f6>신랑측</h4>
      <div class="space-y-2 text-sm" data-astro-cid-j7pv25f6>
       <div data-astro-cid-j7pv25f6>
        <p class="font-medium" data-astro-cid-j7pv25f6>김철수</p>
        <button class="text-blue-600 underline" data-astro-cid-j7pv25f6>010-1234-5678</button>
       </div>
       <div data-astro-cid-j7pv25f6>
        <p class="font-medium" data-astro-cid-j7pv25f6>아버지 김○○</p>
        <button class="text-blue-600 underline" data-astro-cid-j7pv25f6>010-1111-2222</button>
       </div>
       <div data-astro-cid-j7pv25f6>
        <p class="font-medium" data-astro-cid-j7pv25f6>어머니 박○○</p>
        <button class="text-blue-600 underline" data-astro-cid-j7pv25f6>010-3333-4444</button>
       </div>
      </div>
     </div>
     <!-- 신부측 -->
     <div class="text-center bg-pink-50 rounded-lg p-4" data-astro-cid-j7pv25f6>
      <h4 class="font-semibold mb-3 text-pink-800" data-astro-cid-j7pv25f6>신부측</h4>
      <div class="space-y-2 text-sm" data-astro-cid-j7pv25f6>
       <div data-astro-cid-j7pv25f6>
        <p class="font-medium" data-astro-cid-j7pv25f6>이영희</p>
        <button class="text-pink-600 underline" data-astro-cid-j7pv25f6>010-5678-9012</button>
       </div>
       <div data-astro-cid-j7pv25f6>
        <p class="font-medium" data-astro-cid-j7pv25f6>아버지 이○○</p>
        <button class="text-pink-600 underline" data-astro-cid-j7pv25f6>010-5555-6666</button>
       </div>
       <div data-astro-cid-j7pv25f6>
        <p class="font-medium" data-astro-cid-j7pv25f6>어머니 최○○</p>
        <button class="text-pink-600 underline" data-astro-cid-j7pv25f6>010-7777-8888</button>
       </div>
      </div>
     </div>
    </div>
   </section>
   
   <!-- Phase 2: 거의 필수 요소 -->
   <!-- 7. 사진 갤러리 -->
   <section class="px-6 py-8" data-astro-cid-j7pv25f6>
    <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>갤러리</h3>
    <div class="grid grid-cols-2 gap-3" data-astro-cid-j7pv25f6>
     <div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300" data-astro-cid-j7pv25f6>
      <span class="text-gray-500 text-sm" data-astro-cid-j7pv25f6>[사진1]</span>
     </div>
     <div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300" data-astro-cid-j7pv25f6>
      <span class="text-gray-500 text-sm" data-astro-cid-j7pv25f6>[사진2]</span>
     </div>
     <div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300" data-astro-cid-j7pv25f6>
      <span class="text-gray-500 text-sm" data-astro-cid-j7pv25f6>[사진3]</span>
     </div>
     <div class="aspect-square bg-gray-200 rounded-lg flex items-center justify-center border-2 border-dashed border-gray-300" data-astro-cid-j7pv25f6>
      <span class="text-gray-500 text-sm" data-astro-cid-j7pv25f6>[사진4]</span>
     </div>
    </div>
    <div class="text-center mt-4" data-astro-cid-j7pv25f6>
     <button class="text-rose-600 underline text-sm" data-astro-cid-j7pv25f6>더 많은 사진 보기</button>
    </div>
   </section>
   
   <!-- 8. 계좌 정보 -->
   <section class="px-6 py-8" data-astro-cid-j7pv25f6>
    <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>마음 전하실 곳</h3>
    <div class="space-y-4" data-astro-cid-j7pv25f6>
     <!-- 신랑측 계좌 -->
     <div class="bg-blue-50 rounded-lg p-4" data-astro-cid-j7pv25f6>
      <h4 class="font-semibold mb-3 text-blue-800 text-center" data-astro-cid-j7pv25f6>신랑측</h4>
      <div class="space-y-2" data-astro-cid-j7pv25f6>
       <div class="flex justify-between items-center bg-white rounded p-3" data-astro-cid-j7pv25f6>
        <div data-astro-cid-j7pv25f6>
         <p class="font-medium" data-astro-cid-j7pv25f6>국민은행</p>
         <p class="text-sm text-gray-600" data-astro-cid-j7pv25f6>123-456-789012</p>
         <p class="text-sm" data-astro-cid-j7pv25f6>예금주: 김철수</p>
        </div>
        <button class="text-blue-600 text-sm underline" data-astro-cid-j7pv25f6>복사</button>
       </div>
      </div>
     </div>
     <!-- 신부측 계좌 -->
     <div class="bg-pink-50 rounded-lg p-4" data-astro-cid-j7pv25f6>
      <h4 class="font-semibold mb-3 text-pink-800 text-center" data-astro-cid-j7pv25f6>신부측</h4>
      <div class="space-y-2" data-astro-cid-j7pv25f6>
       <div class="flex justify-between items-center bg-white rounded p-3" data-astro-cid-j7pv25f6>
        <div data-astro-cid-j7pv25f6>
         <p class="font-medium" data-astro-cid-j7pv25f6>신한은행</p>
         <p class="text-sm text-gray-600" data-astro-cid-j7pv25f6>987-654-321098</p>
         <p class="text-sm" data-astro-cid-j7pv25f6>예금주: 이영희</p>
        </div>
        <button class="text-pink-600 text-sm underline" data-astro-cid-j7pv25f6>복사</button>
       </div>
      </div>
     </div>
    </div>
   </section>
   
   <!-- 9. 상세 인사말 -->
   <section class="px-6 py-8" data-astro-cid-j7pv25f6>
    <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>진심을 담아</h3>
    <div class="bg-gradient-to-b from-rose-50 to-white rounded-lg p-6" data-astro-cid-j7pv25f6>
     <p class="text-gray-700 leading-relaxed text-center" data-astro-cid-j7pv25f6>
      [상세 인사말]<br data-astro-cid-j7pv25f6><br data-astro-cid-j7pv25f6>
      안녕하세요, 저희는 3년 전 대학교 동아리에서 만나<br data-astro-cid-j7pv25f6>
      서로의 소중함을 알게 되었습니다.<br data-astro-cid-j7pv25f6><br data-astro-cid-j7pv25f6>
      이제 평생을 함께하겠다는 약속을 하려 합니다.<br data-astro-cid-j7pv25f6>
      바쁘신 중에도 저희의 소중한 순간을<br data-astro-cid-j7pv25f6>
      함께해 주시는 모든 분들께 감사드립니다.<br data-astro-cid-j7pv25f6><br data-astro-cid-j7pv25f6>
      앞으로도 변함없는 사랑과 격려<br data-astro-cid-j7pv25f6>
      부탁드립니다.
     </p>
    </div>
   </section>
   
   <!-- Phase 3: 자주 포함 요소 -->
   <!-- 10. 달력/카운트다운 -->
   <section class="px-6 py-8" data-astro-cid-j7pv25f6>
    <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>결혼식까지</h3>
    <div class="text-center bg-gradient-to-b from-rose-100 to-rose-50 rounded-lg p-6" data-astro-cid-j7pv25f6>
     <div class="text-3xl font-bold text-rose-800 mb-2" data-astro-cid-j7pv25f6>
      [D-30]
     </div>
     <p class="text-gray-600" data-astro-cid-j7pv25f6>2024년 10월 25일까지</p>
     <!-- 간단한 달력 표시 -->
     <div class="mt-6 bg-white rounded-lg p-4" data-astro-cid-j7pv25f6>
      <p class="text-sm text-gray-500 mb-2" data-astro-cid-j7pv25f6>2024년 10월</p>
      <div class="w-full h-24 bg-gray-100 rounded flex items-center justify-center" data-astro-cid-j7pv25f6>
       <span class="text-gray-500" data-astro-cid-j7pv25f6>[달력 위젯]</span>
      </div>
     </div>
    </div>
   </section>
   
   <!-- 11. 교통편 안내 -->
   <section class="px-6 py-8" data-astro-cid-j7pv25f6>
    <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>교통편 안내</h3>
    <div class="space-y-4" data-astro-cid-j7pv25f6>
     <!-- 지하철 -->
     <div class="bg-blue-50 rounded-lg p-4" data-astro-cid-j7pv25f6>
      <h4 class="font-semibold mb-2 text-blue-800 flex items-center" data-astro-cid-j7pv25f6>
       🚇 지하철
      </h4>
      <p class="text-sm text-gray-700" data-astro-cid-j7pv25f6>
       2호선 강남역 3번 출구 도보 5분<br data-astro-cid-j7pv25f6>
       9호선 신논현역 1번 출구 도보 3분
      </p>
     </div>
     <!-- 버스 -->
     <div class="bg-green-50 rounded-lg p-4" data-astro-cid-j7pv25f6>
      <h4 class="font-semibold mb-2 text-green-800 flex items-center" data-astro-cid-j7pv25f6>
       🚌 버스
      </h4>
      <p class="text-sm text-gray-700" data-astro-cid-j7pv25f6>
       강남 02, 421, 463번<br data-astro-cid-j7pv25f6>
       '강남역' 하차 후 도보 5분
      </p>
     </div>
     <!-- 주차 -->
     <div class="bg-purple-50 rounded-lg p-4" data-astro-cid-j7pv25f6>
      <h4 class="font-semibold mb-2 text-purple-800 flex items-center" data-astro-cid-j7pv25f6>
       🚗 주차
      </h4>
      <p class="text-sm text-gray-700" data-astro-cid-j7pv25f6>
       지하 1층~3층 (3시간 무료)<br data-astro-cid-j7pv25f6>
       발렛파킹 가능 (1만원)
      </p>
     </div>
    </div>
   </section>
   
   <!-- 12. 배경음악 -->
   <section class="px-6 py-8" data-astro-cid-j7pv25f6>
    <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>함께 들어요</h3>
    <div class="bg-gradient-to-r from-rose-100 to-pink-100 rounded-lg p-6 text-center" data-astro-cid-j7pv25f6>
     <div class="w-full h-16 bg-white rounded-lg flex items-center justify-center mb-4" data-astro-cid-j7pv25f6>
      <span class="text-gray-500" data-astro-cid-j7pv25f6>[음악 플레이어]</span>
     </div>
     <p class="text-sm text-gray-700 mb-2" data-astro-cid-j7pv25f6>우리의 특별한 노래</p>
     <p class="text-xs text-gray-500" data-astro-cid-j7pv25f6>"All of Me" - John Legend</p>
     <div class="flex justify-center gap-4 mt-4" data-astro-cid-j7pv25f6>
      <button class="bg-white rounded-full w-12 h-12 flex items-center justify-center shadow" data-astro-cid-j7pv25f6>
       ▶️
      </button>
      <button class="bg-white rounded-full w-12 h-12 flex items-center justify-center shadow" data-astro-cid-j7pv25f6>
       🔇
      </button>
     </div>
    </div>
   </section>
   
   <!-- Phase 4: 선택적 요소 -->
   <!-- 13. 연애 스토리 -->
   <section class="px-6 py-8" data-astro-cid-j7pv25f6>
    <h3 class="text-xl font-semibold text-center mb-6 text-rose-800" data-astro-cid-j7pv25f6>우리의 이야기</h3>
    <div class="space-y-6" data-astro-cid-j7pv25f6>
     <!-- 타임라인 아이템 -->
     <div class="flex gap-4" data-astro-cid-j7pv25f6>
      <div class="w-12 h-12 bg-rose-200 rounded-full flex items-center justify-center flex-shrink-0" data-astro-cid-j7pv25f6>
       💕
      </div>
      <div data-astro-cid-j7pv25f6>
       <h4 class="font-semibold text-rose-800" data-astro-cid-j7pv25f6>2019.03 첫 만남</h4>
       <p class="text-sm text-gray-600 mt-1" data-astro-cid-j7pv25f6>대학교 동아리에서 처음 만났어요</p>
      </div>
     </div>
     <div class="flex gap-4" data-astro-cid-j7pv25f6>
      <div class="w-12 h-12 bg-pink-200 rounded-full flex items-center justify-center flex-shrink-0" data-astro-cid-j7pv25f6>
       💖
      </div>
      <div data-astro-cid-j7pv25f6>
       <h4 class="font-semibold text-pink-800" data-astro-cid-j7pv25f6>2020.05 첫 고백</h4>
       <p class="text-sm text-gray-600 mt-1" data-astro-cid-j7pv25f6>코로나로 힘든 시기, 서로가 힘이 되어주었어요</p>
      </div>
     </div>
     <div class="flex gap-4" data-astro-cid-j7pv25f6>
      <div class="w-12 h-12 bg-red-200 rounded-full flex items-center justify-center flex-shrink-0" data-astro-cid-j7pv25f6>
       💍
      </div>
      <div data-astro-cid-j7pv25f6>
       <h4 class="font-semibold text-red-800" data-astro-cid-j7pv25f6>2022.12 프로포즈</h4>
       <p class="text-sm text-gray-600 mt-1" data-astro-cid-j7pv25f6>눈 내리는 겨울날, 특별한 순간이었어요</p>
      </div>
     </div>
     <div class="flex gap-4" data-astro-cid-j7pv25f6>
      <div class="w-12 h-12 bg-rose-300 rounded-full flex items-center justify-center flex-shrink-0" data-astro-cid-j7pv25f6>
       💒
      </div>
      <div data-astro-cid-j7pv25f6>
       <h4 class="font-semibold text-rose-800" data-astro-cid-j7pv25f6>2024.10 결혼</h4>
       <p class="text-sm text-gray-600 mt-1" data-astro-cid-j7pv25f6>드디어 평생을 함께하게 되었습니다</p>
      </div>
     </div>
    </div>
   </section>
   
   <!-- 푸터 -->
   <footer class="px-6 py-8 text-center bg-rose-100" data-astro-cid-j7pv25f6>
    <p class="text-sm text-gray-600 mb-2" data-astro-cid-j7pv25f6>
     김철수 ♥ 이영희
    </p>
    <p class="text-xs text-gray-500" data-astro-cid-j7pv25f6>
     2024년 10월 25일 토요일 오후 2시<br data-astro-cid-j7pv25f6>
     서울웨딩홀 3층 그레이스홀
    </p>
   </footer>
   
  </main>
  
  <!-- 커튼 애니메이션 스크립트 -->
  <script>
   console.log('커튼 애니메이션 로딩 중...');
   
   class CurtainEffect {
    constructor() {
     this.viewportWidth = window.innerWidth;
     this.viewportHeight = window.innerHeight;
     this.centerX = this.viewportWidth / 2;
     this.centerY = this.viewportHeight * 2 / 3;
     
     // 페이즈별 독립적 시간 설정
     this.initialWaitDuration = 1000; // 초기 1초 대기
     this.phase0Duration = 500; // 초기 회색 가로줄 생성
     this.phase0WaitDuration = 1000; // 휴면 시간
     this.phase1Duration = 400; // 꼭지점 이동
     this.phase2Duration = 300; // 대기 시간
     this.phase3Duration = 2000; // 커튼 이동 + 주름
     this.totalDuration = this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration + 
      this.phase1Duration + this.phase2Duration + this.phase3Duration;
     
     this.startTime = null;
     this.wrinkleLines = [];
     
     this.init();
    }
    
    init() {
     console.log('커튼 초기화 중...');
     this.setupCurtains();
     this.setupWrinkles();
     this.setupInitialGrayLines();
     this.startAnimation();
    }
    
    setupCurtains() {
     const topLeft = document.getElementById('curtain-top-left');
     const topRight = document.getElementById('curtain-top-right');
     const bottomLeft = document.getElementById('curtain-bottom-left');
     const bottomRight = document.getElementById('curtain-bottom-right');
     
     // 초기 위치 설정 - 화면 전체를 덮음
     topLeft.style.left = '0px';
     topLeft.style.top = '0px';
     topLeft.style.width = this.centerX + 'px';
     topLeft.style.height = this.centerY + 'px';
     
     topRight.style.left = this.centerX + 'px';
     topRight.style.top = '0px';
     topRight.style.width = (this.viewportWidth - this.centerX) + 'px';
     topRight.style.height = this.centerY + 'px';
     
     bottomLeft.style.left = '0px';
     bottomLeft.style.top = this.centerY + 'px';
     bottomLeft.style.width = this.centerX + 'px';
     bottomLeft.style.height = (this.viewportHeight - this.centerY) + 'px';
     
     bottomRight.style.left = this.centerX + 'px';
     bottomRight.style.top = this.centerY + 'px';
     bottomRight.style.width = (this.viewportWidth - this.centerX) + 'px';
     bottomRight.style.height = (this.viewportHeight - this.centerY) + 'px';
    }
    
    setupWrinkles() {
     const container = document.getElementById('wrinkles-container');
     if (!container) return;
     
     // 각 사각형마다 5개씩 세로선 생성 (총 20개)
     const sections = [
      { id: 'top-left', x: 0, y: 0, w: this.centerX, h: this.centerY },
      { id: 'top-right', x: this.centerX, y: 0, w: this.viewportWidth - this.centerX, h: this.centerY },
      { id: 'bottom-left', x: 0, y: this.centerY, w: this.centerX, h: this.viewportHeight - this.centerY },
      { id: 'bottom-right', x: this.centerX, y: this.centerY, w: this.viewportWidth - this.centerX, h: this.viewportHeight - this.centerY }
     ];
     
     sections.forEach(section => {
      for (let i = 1; i <= 5; i++) {
       const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
       line.classList.add('wrinkle-line');
       line.dataset.section = section.id;
       line.dataset.index = i;
       
       const isLeftSection = section.id.includes('left');
       const sectionWidth = isLeftSection ? this.centerX : (this.viewportWidth - this.centerX);
       const spacing = sectionWidth / 6;
       
       const x = isLeftSection ? 
        (spacing * i) : 
        (this.centerX + (spacing * i));
       
       line.setAttribute('x1', x);
       line.setAttribute('y1', section.y);
       line.setAttribute('x2', x);
       line.setAttribute('y2', section.y + section.h);
       line.setAttribute('stroke', '#d1d5db');
       line.setAttribute('stroke-width', '3');
       line.setAttribute('opacity', '0');
       
       container.appendChild(line);
       this.wrinkleLines.push({
        element: line,
        section: section.id,
        index: i,
        originalX: x,
        originalY: section.y,
        originalHeight: section.h,
        activated: false,
        screenPointMoving: false,
        activationCurtainMove: null,
        rotationEndCoords: null,
        linearStartPhaseProgress: null,
        activationTime: null,
        fadeInDelay: 0,
        fadeInDuration: 150
       });
      }
     });
    }
    
    setupInitialGrayLines() {
     const leftLine = document.getElementById('initial-gray-line-left');
     const rightLine = document.getElementById('initial-gray-line-right');
     
     leftLine.style.left = '0px';
     leftLine.style.top = this.centerY + 'px';
     leftLine.style.width = this.centerX + 'px';
     
     rightLine.style.left = this.centerX + 'px';
     rightLine.style.top = this.centerY + 'px';
     rightLine.style.width = (this.viewportWidth - this.centerX) + 'px';
    }
    
    startAnimation() {
     console.log('애니메이션 시작!');
     this.startTime = performance.now();
     this.animate();
    }
    
    animate() {
     const currentTime = performance.now();
     const elapsed = currentTime - this.startTime;
     
     let currentPhase, phaseProgress;
     
     if (elapsed <= this.initialWaitDuration) {
      currentPhase = -1;
      phaseProgress = elapsed / this.initialWaitDuration;
     } else if (elapsed <= this.initialWaitDuration + this.phase0Duration) {
      currentPhase = 0;
      phaseProgress = (elapsed - this.initialWaitDuration) / this.phase0Duration;
     } else if (elapsed <= this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration) {
      currentPhase = 0.5;
      phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration) / this.phase0WaitDuration;
     } else if (elapsed <= this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration + this.phase1Duration) {
      currentPhase = 1;
      phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration - this.phase0WaitDuration) / this.phase1Duration;
     } else if (elapsed <= this.initialWaitDuration + this.phase0Duration + this.phase0WaitDuration + this.phase1Duration + this.phase2Duration) {
      currentPhase = 2;
      phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration - this.phase0WaitDuration - this.phase1Duration) / this.phase2Duration;
     } else if (elapsed <= this.totalDuration) {
      currentPhase = 3;
      phaseProgress = (elapsed - this.initialWaitDuration - this.phase0Duration - this.phase0WaitDuration - this.phase1Duration - this.phase2Duration) / this.phase3Duration;
     } else {
      currentPhase = 4;
      phaseProgress = 1;
     }
     
     this.updateInitialOverlay(currentPhase, phaseProgress);
     this.updateInitialGrayLines(currentPhase, phaseProgress);
     this.updateCurtains(currentPhase, phaseProgress);
     this.updateWrinkles(currentPhase, phaseProgress);
     
     if (currentPhase < 4) {
      requestAnimationFrame(() => this.animate());
     } else {
      this.cleanup();
     }
    }
    
    updateInitialOverlay(currentPhase, phaseProgress) {
     const initialOverlay = document.getElementById('initial-overlay');
     if (!initialOverlay) return;
     
     if (currentPhase === -1) {
      const opacity = this.easeOutCubic(phaseProgress);
      initialOverlay.style.opacity = opacity;
     } else if (currentPhase >= 0) {
      initialOverlay.style.opacity = '1';
     }
    }
    
    updateInitialGrayLines(currentPhase, phaseProgress) {
     const leftLine = document.getElementById('initial-gray-line-left');
     const rightLine = document.getElementById('initial-gray-line-right');
     
     if (currentPhase === -1) {
      leftLine.style.opacity = '0';
      rightLine.style.opacity = '0';
     } else if (currentPhase === 0) {
      const opacity = this.easeOutCubic(phaseProgress);
      leftLine.style.opacity = opacity;
      rightLine.style.opacity = opacity;
     } else if (currentPhase === 0.5) {
      leftLine.style.opacity = '1';
      rightLine.style.opacity = '1';
     } else if (currentPhase === 1) {
      const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
      const cornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
      
      leftLine.style.left = '0px';
      leftLine.style.width = (this.centerX - cornerMove) + 'px';
      
      rightLine.style.left = (this.centerX + cornerMove) + 'px';
      rightLine.style.width = (this.viewportWidth - this.centerX - cornerMove) + 'px';
     } else if (currentPhase === 2) {
      const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
      
      leftLine.style.left = '0px';
      leftLine.style.width = (this.centerX - maxCornerMove) + 'px';
      leftLine.style.opacity = '1';
      
      rightLine.style.left = (this.centerX + maxCornerMove) + 'px';
      rightLine.style.width = (this.viewportWidth - this.centerX - maxCornerMove) + 'px';
      rightLine.style.opacity = '1';
     } else if (currentPhase === 3) {
      const maxMove = this.viewportWidth * 1.5;
      const fastMove = maxMove * this.easeInCubic(phaseProgress * 1.5);
      const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
      
      leftLine.style.transform = `translateX(${-fastMove}px)`;
      leftLine.style.left = '0px';
      leftLine.style.width = (this.centerX - maxCornerMove) + 'px';
      leftLine.style.opacity = '1';
      
      rightLine.style.transform = `translateX(${fastMove}px)`;
      rightLine.style.left = (this.centerX + maxCornerMove) + 'px';
      rightLine.style.width = (this.viewportWidth - this.centerX - maxCornerMove) + 'px';
      rightLine.style.opacity = '1';
     }
    }
    
    updateCurtains(currentPhase, phaseProgress) {
     const topLeft = document.getElementById('curtain-top-left');
     const topRight = document.getElementById('curtain-top-right');
     const bottomLeft = document.getElementById('curtain-bottom-left');
     const bottomRight = document.getElementById('curtain-bottom-right');
     const initialOverlay = document.getElementById('initial-overlay');
     
     if (currentPhase === 1) {
      if (initialOverlay) {
       initialOverlay.remove();
      }
      const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
      const cornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
      
      topLeft.style.clipPath = `polygon(0% 0%, 100% 0%, ${100 - (cornerMove/this.centerX)*100}% 100%, 0% 100%)`;
      topRight.style.clipPath = `polygon(${(cornerMove/(this.viewportWidth-this.centerX))*100}% 100%, 100% 100%, 100% 0%, 0% 0%)`;
      bottomLeft.style.clipPath = `polygon(0% 0%, ${100 - (cornerMove/this.centerX)*100}% 0%, 100% 100%, 0% 100%)`;
      bottomRight.style.clipPath = `polygon(${(cornerMove/(this.viewportWidth-this.centerX))*100}% 0%, 100% 0%, 100% 100%, 0% 100%)`;
     } else if (currentPhase === 2) {
      const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
      
      topLeft.style.clipPath = `polygon(0% 0%, 100% 0%, ${100 - (maxCornerMove/this.centerX)*100}% 100%, 0% 100%)`;
      topRight.style.clipPath = `polygon(${(maxCornerMove/(this.viewportWidth-this.centerX))*100}% 100%, 100% 100%, 100% 0%, 0% 0%)`;
      bottomLeft.style.clipPath = `polygon(0% 0%, ${100 - (maxCornerMove/this.centerX)*100}% 0%, 100% 100%, 0% 100%)`;
      bottomRight.style.clipPath = `polygon(${(maxCornerMove/(this.viewportWidth-this.centerX))*100}% 0%, 100% 0%, 100% 100%, 0% 100%)`;
     } else if (currentPhase === 3) {
      const maxMove = this.viewportWidth * 1.5;
      const normalMove = maxMove * this.easeInCubic(phaseProgress);
      const fastMove = maxMove * this.easeInCubic(phaseProgress * 1.5);
      
      const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
      
      const fastCornerX = this.centerX - maxCornerMove - fastMove;
      const fastCornerXRight = this.centerX + maxCornerMove + fastMove;
      
      topLeft.style.transform = `translateX(${-normalMove}px)`;
      topLeft.style.clipPath = `polygon(0% 0%, 100% 0%, ${((fastCornerX + normalMove) / this.centerX) * 100}% 100%, 0% 100%)`;
      
      topRight.style.transform = `translateX(${normalMove}px)`;
      topRight.style.clipPath = `polygon(${((fastCornerXRight - normalMove - this.centerX) / this.centerX) * 100}% 100%, 100% 100%, 100% 0%, 0% 0%)`;
      
      bottomLeft.style.transform = `translateX(${-normalMove}px)`;
      bottomLeft.style.clipPath = `polygon(0% 0%, ${((fastCornerX + normalMove) / this.centerX) * 100}% 0%, 100% 100%, 0% 100%)`;
      
      bottomRight.style.transform = `translateX(${normalMove}px)`;
      bottomRight.style.clipPath = `polygon(${((fastCornerXRight - normalMove - this.centerX) / this.centerX) * 100}% 0%, 100% 0%, 100% 100%, 0% 100%)`;
     }
    }
    
    updateWrinkles(currentPhase, phaseProgress) {
     let leftCornerX = null;
     let rightCornerX = null;
     
     if (currentPhase === 1) {
      const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
      const currentCornerMove = maxCornerMove * this.easeOutCubic(phaseProgress);
      
      leftCornerX = this.centerX - currentCornerMove;
      rightCornerX = this.centerX + currentCornerMove;
     } else if (currentPhase >= 3) {
      const maxCornerMove = Math.min(this.centerX, this.centerY) * 0.2;
      const maxMove = this.viewportWidth * 1.5;
      const fastMove = maxMove * this.easeInCubic(phaseProgress * 1.5);
      
      leftCornerX = this.centerX - maxCornerMove - fastMove;
      rightCornerX = this.centerX + maxCornerMove + fastMove;
     }
     
     if (leftCornerX !== null && rightCornerX !== null) {
      this.wrinkleLines.forEach((wrinkle) => {
       if (!wrinkle.activated) {
        const wrinkleX = wrinkle.originalX;
        const isLeftSection = wrinkle.section.includes('left');
        
        const sectionWidth = isLeftSection ? this.centerX : (this.viewportWidth - this.centerX);
        const spacing = sectionWidth / 6;
        const earlyOffset = spacing / 5;
        
        const shouldActivate = isLeftSection ?
         (leftCornerX <= (wrinkleX + earlyOffset)) :
         (rightCornerX >= (wrinkleX - earlyOffset));
        
        if (shouldActivate) {
         wrinkle.element.classList.add('wrinkle-visible');
         wrinkle.activated = true;
         wrinkle.activationTime = performance.now();
         
         wrinkle.fadeInDelay = 0;
         wrinkle.fadeInDuration = 150;
        }
       }
       
       if (wrinkle.activated) {
        const currentTime = performance.now();
        const elapsed = currentTime - wrinkle.activationTime;
        
        if (elapsed >= wrinkle.fadeInDelay) {
         const fadeElapsed = elapsed - wrinkle.fadeInDelay;
         
         if (fadeElapsed < wrinkle.fadeInDuration) {
          const progress = fadeElapsed / wrinkle.fadeInDuration;
          const opacity = 0.8 * this.easeOutCubic(progress);
          wrinkle.element.setAttribute('opacity', Math.max(0, opacity).toString());
         } else {
          wrinkle.element.setAttribute('opacity', '0.8');
         }
        } else {
         wrinkle.element.setAttribute('opacity', '0');
        }
        
        if (!wrinkle.screenPointMoving) {
         const isLeftSection = wrinkle.section.includes('left');
         const sectionWidth = isLeftSection ? this.centerX : (this.viewportWidth - this.centerX);
         const spacing = sectionWidth / 6;
         
         const n = isLeftSection ?
          (5 - wrinkle.index) :
          (wrinkle.index - 1);
         
         const curtainMovingX = isLeftSection ? leftCornerX : rightCornerX;
         const curtainTotalMove = Math.abs(curtainMovingX - this.centerX);
         
         if (wrinkle.activationCurtainMove === null) {
          wrinkle.activationCurtainMove = curtainTotalMove;
         }
         
         const additionalMoveNeeded = spacing * (6 - n) / 6;
         const rotationStopMove = wrinkle.activationCurtainMove + additionalMoveNeeded;
         
         if (curtainTotalMove >= rotationStopMove) {
          const isTopSection = wrinkle.section.includes('top');
          wrinkle.rotationEndCoords = {
           screenX: isTopSection ? parseFloat(wrinkle.element.getAttribute('x1')) : parseFloat(wrinkle.element.getAttribute('x2')),
           screenY: isTopSection ? parseFloat(wrinkle.element.getAttribute('y1')) : parseFloat(wrinkle.element.getAttribute('y2')),
           curtainX: isTopSection ? parseFloat(wrinkle.element.getAttribute('x2')) : parseFloat(wrinkle.element.getAttribute('x1')),
           curtainY: isTopSection ? parseFloat(wrinkle.element.getAttribute('y2')) : parseFloat(wrinkle.element.getAttribute('y1'))
          };
          
          wrinkle.linearStartCurtainX = isLeftSection ? leftCornerX : rightCornerX;
          wrinkle.linearStartPhaseProgress = phaseProgress;
          wrinkle.screenPointMoving = true;
         }
        }
        
        if (wrinkle.screenPointMoving) {
         this.updateWrinkleLinearMovement(wrinkle, currentPhase, phaseProgress, leftCornerX, rightCornerX);
        } else {
         this.updateWrinkleTilt(wrinkle, currentPhase, phaseProgress, leftCornerX, rightCornerX);
        }
       }
      });
     }
    }
    
    updateWrinkleTilt(wrinkle, currentPhase, phaseProgress, leftCornerX, rightCornerX) {
     const isLeftSection = wrinkle.section.includes('left');
     const isTopSection = wrinkle.section.includes('top');
     
     const fixedX = wrinkle.originalX;
     const fixedY = isTopSection ? wrinkle.originalY : (wrinkle.originalY + wrinkle.originalHeight);
     
     const cornerX = isLeftSection ? leftCornerX : rightCornerX;
     const cornerY = this.centerY;
     
     if (cornerX !== undefined && cornerY !== undefined) {
      const movingX = cornerX;
      const movingY = this.centerY;
      
      if (isTopSection) {
       wrinkle.element.setAttribute('x1', fixedX);
       wrinkle.element.setAttribute('y1', fixedY);
       wrinkle.element.setAttribute('x2', movingX);
       wrinkle.element.setAttribute('y2', movingY);
      } else {
       wrinkle.element.setAttribute('x1', movingX);
       wrinkle.element.setAttribute('y1', movingY);
       wrinkle.element.setAttribute('x2', fixedX);
       wrinkle.element.setAttribute('y2', fixedY);
      }
     }
    }
    
    updateWrinkleLinearMovement(wrinkle, currentPhase, phaseProgress, leftCornerX, rightCornerX) {
     const isLeftSection = wrinkle.section.includes('left');
     const isTopSection = wrinkle.section.includes('top');
     
     const cornerX = isLeftSection ? leftCornerX : rightCornerX;
     const cornerY = this.centerY;
     
     if (cornerX !== undefined && cornerY !== undefined) {
      const direction = isLeftSection ? -1 : 1;
      const maxMove = this.viewportWidth * 1.5;
      
      const totalScreenMove = maxMove * this.easeInCubic(phaseProgress);
      const startingScreenMove = maxMove * this.easeInCubic(wrinkle.linearStartPhaseProgress);
      const screenMove = totalScreenMove - startingScreenMove;
      
      const screenMovingX = wrinkle.rotationEndCoords.screenX + (direction * screenMove);
      const screenMovingY = wrinkle.rotationEndCoords.screenY;
      
      if (isTopSection) {
       wrinkle.element.setAttribute('x1', screenMovingX);
       wrinkle.element.setAttribute('y1', screenMovingY);
       wrinkle.element.setAttribute('x2', cornerX);
       wrinkle.element.setAttribute('y2', cornerY);
      } else {
       wrinkle.element.setAttribute('x1', cornerX);
       wrinkle.element.setAttribute('y1', cornerY);
       wrinkle.element.setAttribute('x2', screenMovingX);
       wrinkle.element.setAttribute('y2', screenMovingY);
      }
     }
    }
    
    cleanup() {
     console.log('애니메이션 완료 및 정리 중...');
     const blackScreen = document.getElementById('black-screen');
     const overlay = document.getElementById('curtain-overlay');
     
     if (blackScreen) {
      blackScreen.style.transition = 'opacity 500ms ease-out';
      blackScreen.style.opacity = '0';
      
      setTimeout(() => {
       overlay.style.opacity = '0';
       setTimeout(() => {
        overlay.remove();
        console.log('커튼 애니메이션 완료!');
       }, 300);
      }, 500);
     } else {
      overlay.style.opacity = '0';
      setTimeout(() => {
       overlay.remove();
       console.log('커튼 애니메이션 완료!');
      }, 300);
     }
    }
    
    // 이징 함수들
    easeOutCubic(t) {
     return 1 - Math.pow(1 - t, 3);
    }
    
    easeInCubic(t) {
     return t * t * t;
    }
    
    easeOutQuad(t) {
     return 1 - (1 - t) * (1 - t);
    }
   }
   
   // 페이지 로드 시 커튼 효과 시작
   window.addEventListener('load', () => {
    console.log('페이지 로드 완료! 커튼 효과 시작!');
    window.curtainEffectInstance = new CurtainEffect();
   });
   
   // 페이지가 이미 로드된 경우를 위한 체크
   if (document.readyState === 'complete') {
    console.log('페이지 이미 로드됨! 커튼 효과 시작!');
    window.curtainEffectInstance = new CurtainEffect();
   }
  </script>
  
 </body>
</html>